let textTexture;let p5Canvas; // UI Elementslet textInput, sizeSlider, widthSlider, thicknessSlider, colorPicker, sphereSizeSlider, bgColorPicker;let vCoverageSlider, hCoverageSlider, bundleVCheck, bundleHCheck, rotationCheck, rotationSpeedSlider;let btnGif, btnPng, fontSelect, fontUpload;// NEW TOGGLE & NOTIFICATIONlet depthCheck;let notification;// Display Text Elementslet currentHeightDisplay, currentWidthDisplay, currentThicknessDisplay, currentSphereSizeDisplay;let currentVCoverageDisplay, currentHCoverageDisplay;// State Variableslet sphereText = "MAKE IT\nCURVY";let currentTextSize = 60;let currentTextScaleX = 1.0;let currentStrokeWidth = 0;let currentTextColor = '#FFFF00';let currentSphereSize = 180;let currentBgColor = '#1a1a1a';let currentVCoverage = 50;let currentHCoverage = 50;let isVBundled = false;let isHBundled = false;let isAutoRotating = true;let isDepthEnabled = true; const detail = 60;let currentFont = 'Inter'; // Physicslet totalRotationX = 0;let totalRotationY = 0;let velocityX = 0;let velocityY = 0;let isDragging = false;const friction = 0.95;const rotationSensitivity = 0.01;let currentAutoSpeed = 0.003;// Export Flaglet isExporting = false;function setup() {  setAttributes('alpha', true);  let canvas = createCanvas(700, 700, WEBGL);  canvas.parent('p5-container');  p5Canvas = canvas.elt;  // 1. Get Elements  textInput = document.getElementById('textInput');  sizeSlider = document.getElementById('sizeSlider');  widthSlider = document.getElementById('widthSlider');  thicknessSlider = document.getElementById('thicknessSlider');  colorPicker = document.getElementById('colorPicker');  sphereSizeSlider = document.getElementById('sphereSizeSlider');  bgColorPicker = document.getElementById('bgColorPicker');  vCoverageSlider = document.getElementById('vCoverageSlider');  hCoverageSlider = document.getElementById('hCoverageSlider');  bundleVCheck = document.getElementById('bundleVCheck');  bundleHCheck = document.getElementById('bundleHCheck');  rotationCheck = document.getElementById('rotationCheck');  rotationSpeedSlider = document.getElementById('rotationSpeedSlider');  btnGif = document.getElementById('btnGif');  btnPng = document.getElementById('btnPng');    depthCheck = document.getElementById('depthCheck');    // NEW NOTIFICATION ELEMENT  notification = document.getElementById('notification');    fontSelect = document.getElementById('fontSelect');  fontUpload = document.getElementById('fontUpload');  // Display Elements  currentHeightDisplay = document.getElementById('currentHeight');  currentWidthDisplay = document.getElementById('currentWidth');  currentThicknessDisplay = document.getElementById('currentThickness');  currentSphereSizeDisplay = document.getElementById('currentSphereSize');  currentVCoverageDisplay = document.getElementById('currentVCoverage');  currentHCoverageDisplay = document.getElementById('currentHCoverage');  // 2. Event Listeners  textInput.addEventListener('input', updateSphereText);  sizeSlider.addEventListener('input', updateTextHeight);  widthSlider.addEventListener('input', updateTextWidth);  thicknessSlider.addEventListener('input', updateThickness);  colorPicker.addEventListener('input', updateTextColor);  sphereSizeSlider.addEventListener('input', updateSphereSize);  bgColorPicker.addEventListener('input', updateBgColor);  vCoverageSlider.addEventListener('input', updateVCoverage);  hCoverageSlider.addEventListener('input', updateHCoverage);  bundleVCheck.addEventListener('change', updateVBundle);  bundleHCheck.addEventListener('change', updateHBundle);  rotationCheck.addEventListener('change', updateRotation);  rotationSpeedSlider.addEventListener('input', updateRotationSpeed);    depthCheck.addEventListener('change', updateDepth);  fontSelect.addEventListener('change', handleFontChange);  fontUpload.addEventListener('change', handleFontUpload);  btnGif.addEventListener('click', saveAnimation);  btnPng.addEventListener('click', saveStaticImage);    // NEW NOTIFICATION CLICK LISTENER  notification.addEventListener('click', hideNotification);  // 3. Initialize  textTexture = createGraphics(1024, 1024);  drawTextureText();  updateBgColor();}// --- NOTIFICATION LOGIC ---function showNotification(msg) {    notification.textContent = msg;    notification.style.display = 'block';}function hideNotification() {    notification.style.display = 'none';}// --- FONT LOGIC ---function handleFontChange() {  let val = fontSelect.value;  if (val === 'upload') {    fontUpload.click();   } else {    currentFont = val;     drawTextureText();  }}function handleFontUpload(e) {  const file = e.target.files[0];  if (file) {    const url = URL.createObjectURL(file);    loadFont(url, (loadedFont) => {      currentFont = loadedFont;       drawTextureText();    });  }}// --- UPDATE FUNCTIONS ---function updateSphereText() { sphereText = textInput.value.toUpperCase(); drawTextureText(); }function updateTextHeight() { currentTextSize = parseInt(sizeSlider.value); currentHeightDisplay.textContent = currentTextSize; drawTextureText(); }function updateTextWidth() { currentTextScaleX = parseFloat(widthSlider.value); currentWidthDisplay.textContent = currentTextScaleX.toFixed(2); drawTextureText(); }function updateThickness() { currentStrokeWidth = parseInt(thicknessSlider.value); currentThicknessDisplay.textContent = currentStrokeWidth; drawTextureText(); }function updateTextColor() { currentTextColor = colorPicker.value; drawTextureText(); }function updateSphereSize() { currentSphereSize = parseInt(sphereSizeSlider.value); currentSphereSizeDisplay.textContent = currentSphereSize; }function updateBgColor() { currentBgColor = bgColorPicker.value; document.body.style.backgroundColor = currentBgColor; }function updateVCoverage() { currentVCoverage = parseInt(vCoverageSlider.value); currentVCoverageDisplay.textContent = currentVCoverage + "%"; drawTextureText(); }function updateHCoverage() { currentHCoverage = parseInt(hCoverageSlider.value); currentHCoverageDisplay.textContent = currentHCoverage + "%"; drawTextureText(); }function updateVBundle() { isVBundled = bundleVCheck.checked; drawTextureText(); }function updateHBundle() { isHBundled = bundleHCheck.checked; drawTextureText(); }function updateRotation() { isAutoRotating = rotationCheck.checked; }function updateRotationSpeed() { currentAutoSpeed = parseFloat(rotationSpeedSlider.value); }function updateDepth() { isDepthEnabled = depthCheck.checked; }// --- EXPORT ---function saveAnimation() {  btnGif.textContent = "Recording...";  btnGif.disabled = true;  isExporting = true;  // 1. Bump resolution for GIF (2x)  pixelDensity(2);  saveGif('sphere_anim', 3, { units: 'seconds' });    setTimeout(() => {    isExporting = false;    pixelDensity(1);        btnGif.textContent = "Save GIF";    btnGif.disabled = false;        // SHOW NOTIFICATION    showNotification("GIF Saved! Click to dismiss.");  }, 3500);}function saveStaticImage() {  isExporting = true;  // 1. Bump resolution for PNG (4x)  pixelDensity(4);    draw();    saveCanvas('sphere_snapshot', 'png');    pixelDensity(1);  isExporting = false;    // SHOW NOTIFICATION  showNotification("Image Saved! Click to dismiss.");}// --- PHYSICS ---function mousePressed() {  if (mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height) {    isDragging = true; velocityX = 0; velocityY = 0;  }}function mouseReleased() { isDragging = false; }function mouseDragged() {  if (isDragging) {    let deltaX = mouseX - pmouseX;    let deltaY = mouseY - pmouseY;    totalRotationY += deltaX * rotationSensitivity;    totalRotationX -= deltaY * rotationSensitivity;    velocityX = deltaX * rotationSensitivity;    velocityY = -deltaY * rotationSensitivity;    return false;  }}// --- DRAW LOOP ---function draw() {  if (isExporting) background(currentBgColor); else clear();  if (!isDragging) {    totalRotationY += velocityX;    totalRotationX += velocityY;    velocityX *= friction; velocityY *= friction;    if (isAutoRotating) totalRotationY += currentAutoSpeed;  }  pointLight(255, 255, 255, 100, 100, 300);  ambientLight(150);  translate(0, 0, 0);  rotateX(totalRotationX);  rotateY(totalRotationY);  noStroke();  let gl = drawingContext;  gl.enable(gl.CULL_FACE);  gl.enable(gl.DEPTH_TEST);    // Toggle depth mask  gl.depthMask(isDepthEnabled);   texture(textTexture);  // INSIDE (BACK)  gl.cullFace(gl.FRONT);  sphere(currentSphereSize, detail, detail);  // OUTSIDE (FRONT)  gl.cullFace(gl.BACK);  sphere(currentSphereSize, detail, detail);  // Cleanup  gl.disable(gl.CULL_FACE);}// --- TEXTURE GEN ---function drawTextureText() {  textTexture.clear();    // Crash fix  if (!sphereText || sphereText.trim().length === 0) {      return;   }    textTexture.textFont(currentFont);  textTexture.fill(currentTextColor);  textTexture.textAlign(CENTER, CENTER);  textTexture.textSize(currentTextSize);  if (currentStrokeWidth > 0) {    textTexture.stroke(currentTextColor);    textTexture.strokeWeight(currentStrokeWidth);    textTexture.strokeJoin(ROUND);  } else {    textTexture.noStroke();  }  textTexture.push();  textTexture.translate(textTexture.width / 2, textTexture.height / 2);  textTexture.scale(currentTextScaleX, 1.0);  let lines = sphereText.split('\n');  let lineHeight = currentTextSize * 1.1;  let singleBlockHeight = lines.length * lineHeight;  let maxLineWidth = 0;  for (let l of lines) {    let w = textTexture.textWidth(l);    if (w > maxLineWidth) maxLineWidth = w;  }  let singleBlockWidth = maxLineWidth;    if (singleBlockWidth < 1) singleBlockWidth = 1;  let strokePadding = currentStrokeWidth * 2;  let maxVRepeats = Math.floor(textTexture.height / (singleBlockHeight + strokePadding));  if (maxVRepeats < 1) maxVRepeats = 1;  let calculatedVRows = Math.floor(maxVRepeats * (currentVCoverage / 100));  if (currentVCoverage > 0 && calculatedVRows < 1) calculatedVRows = 1;  if (currentVCoverage === 0) calculatedVRows = 0;  let effectiveTextureWidth = textTexture.width / currentTextScaleX;  let maxHRepeats = Math.floor(effectiveTextureWidth / (singleBlockWidth + strokePadding));  if (maxHRepeats < 1) maxHRepeats = 1;  let calculatedHCols = Math.floor(maxHRepeats * (currentHCoverage / 100));  if (currentHCoverage > 0 && calculatedHCols < 1) calculatedHCols = 1;  if (currentHCoverage === 0) calculatedHCols = 0;  let vRowHeight, vStartY, hColWidth, hStartX;  if (isVBundled) {    vRowHeight = singleBlockHeight;    let totalVHeight = calculatedVRows * vRowHeight;    vStartY = -totalVHeight / 2 + (vRowHeight / 2);  } else {    vRowHeight = textTexture.height / calculatedVRows;    vStartY = -textTexture.height / 2 + (vRowHeight / 2);  }  if (isHBundled) {    hColWidth = singleBlockWidth * 1.1;    let totalHWidth = calculatedHCols * hColWidth;    hStartX = -totalHWidth / 2 + (hColWidth / 2);  } else {    let spreadWidth = (textTexture.width / currentTextScaleX);    hColWidth = spreadWidth / calculatedHCols;    hStartX = -spreadWidth / 2 + (hColWidth / 2);  }  for (let r = 0; r < calculatedVRows; r++) {    let rowCenterY = vStartY + (r * vRowHeight);    let textStartY = rowCenterY - (singleBlockHeight / 2) + (lineHeight / 2);    for (let h = 0; h < calculatedHCols; h++) {      let colCenterX = hStartX + (h * hColWidth);      for (let i = 0; i < lines.length; i++) {        let currentLineStr = lines[i];        let lineOffsetY = i * lineHeight;        textTexture.text(currentLineStr, colCenterX, textStartY + lineOffsetY);      }    }  }  textTexture.pop();}