// GLOBAL VARIABLESlet sliders = {};let selector, bgSelector;let dirButton; // New Toggle Buttonlet params = {  baseSize: 180,  sides: 6,  noiseScale: 0.6,  symmetry: 6,  trails: 30,  sensitivity: 1.5,  offset: 0.1,  colorMode: 'Rainbow',  bgMode: 'Stars',  layers: 5,  reactionDir: 1 // 1 = Expand, -1 = Implode};// BACKGROUND VARIABLESlet stars = [];const NUM_PARTICLES = 200;// SMOOTHING VARIABLESlet smoothBass = 0;let smoothTreble = 0;let smoothMid = 0;let mic, fft;let audioStarted = false;let startButton, recordButton;let isRecording = false;function setup() {  createCanvas(windowWidth, windowHeight);  colorMode(HSB, 360, 255, 255, 255);  angleMode(DEGREES);  strokeJoin(MITER);  mic = new p5.AudioIn();  fft = new p5.FFT(0.8, 1024);   fft.setInput(mic);    // Initialize Particles  for (let i = 0; i < NUM_PARTICLES; i++) {    stars.push({      x: random(-width, width),      y: random(-height, height),      z: random(width)    });  }    setupUI();}function draw() {  // 1. TRAILS  noStroke();  fill(0, params.trails);  rect(0, 0, width, height);  // --- AUDIO ANALYSIS ---  let bass = 0, mid = 0, treble = 0;  if (audioStarted) {    fft.analyze();    bass = fft.getEnergy("bass");    treble = fft.getEnergy("treble");    mid = fft.getEnergy("lowMid");  }  // SMOOTHING  smoothBass = lerp(smoothBass, bass, 0.05);  smoothTreble = lerp(smoothTreble, treble, 0.05);  smoothMid = lerp(smoothMid, mid * 0.5, 0.02);  updateParams();  translate(width / 2, height / 2);   // 2. BACKGROUND  drawBackground(smoothBass, smoothMid);  noFill();  // --- FRACTAL ANIMATION ---  let t = frameCount * 0.003 + (smoothMid * 0.001);  let baseRotation = frameCount * (0.03 + (smoothMid * 0.0005));  for (let j = 0; j < params.layers; j++) {    let layerScale = map(j, 0, params.layers, 1.0, 0.1);     let dir = (j % 2 === 0) ? 1 : -1;    let layerRotation = baseRotation * dir * (j * 0.5 + 1);     push();     rotate(layerRotation);        for (let i = 0; i < params.symmetry; i++) {      push();      rotate((360 / params.symmetry) * i);            beginShape();      let step = 360 / params.sides;            for (let angle = 0; angle <= 360; angle += step) {                let t_local = t + (i * params.offset) + (j * 0.1);         let xoff = map(cos(angle), -1, 1, 0, params.noiseScale);        let yoff = map(sin(angle), -1, 1, 0, params.noiseScale);        let n = noise(xoff + t_local, yoff + t_local);                 // --- EXPANSION LOGIC ---        // Squared for aggressive "Big Bang" effect        let bigBass = (smoothBass * smoothBass) / 255;                 let bassForce = map(bigBass, 0, 255, 0, 600 * params.sensitivity);        let trebleForce = map(smoothTreble, 0, 255, 0, 100 * params.sensitivity);                // Direction is now controlled by the Toggle Button        let totalChange = (bassForce * params.reactionDir) - (trebleForce * params.reactionDir);        let r = (params.baseSize * layerScale) + (totalChange * layerScale);        r += map(n, 0, 1, -20, 20);        applyColor(angle, t_local, smoothTreble, i, j);                let w = map(smoothBass, 0, 255, 1, 6);        strokeWeight(w);         let x = r * cos(angle);        let y = r * sin(angle);        vertex(x, y);      }      endShape(CLOSE);      pop();    }    pop();   }}function drawBackground(bassLevel, midLevel) {  let dir = params.reactionDir;   let speedBase = (2 + (bassLevel * 0.05));  push();    if (params.bgMode === 'Stars') {    stroke(255, 150);     strokeWeight(2);    for (let i = 0; i < stars.length; i++) {      stars[i].z -= speedBase * 5 * dir;       if (stars[i].z < 1) stars[i].z = width;      if (stars[i].z > width) stars[i].z = 1;      let sx = map(stars[i].x / stars[i].z, 0, 1, 0, width);      let sy = map(stars[i].y / stars[i].z, 0, 1, 0, height);      point(sx, sy);    }  }   else if (params.bgMode === 'Ripples') {    noFill();    stroke(255, 40);     strokeWeight(1);    for (let i = 0; i < 10; i++) {      let r = (frameCount * speedBase * 2 * dir + (i * 100)) % (width * 1.5);      if (r < 0) r += width * 1.5;       ellipse(0, 0, r);    }  }  else if (params.bgMode === 'Grid') {    stroke(255, 40);    strokeWeight(1);    for (let x = -width; x < width; x += 100) {      line(x, -height, x * 0.1, 0);       line(x, height, x * 0.1, 0);      }    let scroll = (frameCount * speedBase * 2 * dir) % 100;    for (let y = 0; y < height/2; y += 50) {       let yPos = y + scroll;        if(yPos < height/2) {         line(-width, -yPos, width, -yPos);          line(-width, yPos, width, yPos);          }    }  }  else if (params.bgMode === 'Vortex') {    noFill();    stroke(255, 30);    strokeWeight(1);    let spin = frameCount * (0.5 + (bassLevel * 0.005)) * dir;    for(let i=0; i<20; i++) {      push();      rotate(spin + (i * 10));       let r = 50 + (i * 50);      arc(0, 0, r, r, 0, 180 + bassLevel);       pop();    }  }  pop();}function applyColor(angle, time, treble, sliceIndex, layerIndex) {  let hueVal;  let sat = 200;  let bri = 255;  let oscillator = sin(angle + frameCount * 1 + (sliceIndex * 10) + (layerIndex * 50));   switch (params.colorMode) {    case 'Rainbow':      hueVal = (angle + frameCount * 0.5 + (layerIndex * 20) + (treble * 0.8)) % 360;      break;    case 'Cyber':      hueVal = map(oscillator, -1, 1, 160, 320); sat = 255; break;    case 'Fire':      hueVal = map(oscillator, -1, 1, 0, 60); sat = 255; break;    case 'Ice':      hueVal = map(oscillator, -1, 1, 160, 260); sat = map(treble, 0, 255, 200, 50); break;    case 'Toxic':      hueVal = map(oscillator, -1, 1, 80, 280); break;  }  let fade = map(layerIndex, 0, params.layers, 255, 50);  stroke(hueVal, sat, bri, fade);}// --- NEW TOGGLE FUNCTION ---function toggleDirection() {  params.reactionDir *= -1;  if (params.reactionDir === 1) {    dirButton.html('PULSE: EXPAND');    dirButton.style('background-color', '#FFF');    dirButton.style('color', '#000');  } else {    dirButton.html('PULSE: IMPLODE');    dirButton.style('background-color', '#333');    dirButton.style('color', '#FFF');  }}function setupUI() {  let uiX = 20;  let uiY = 60;  let gap = 25;    // 1. TOP BUTTONS  startButton = createButton('START AUDIO');  startButton.position(20, 15);  startButton.style('background-color', '#00FF00');  startButton.style('border', 'none');  startButton.style('padding', '8px 16px');  startButton.style('font-weight', 'bold');  startButton.mousePressed(startAudioContext);  recordButton = createButton('RECORD GIF (3s)');  recordButton.position(150, 15);  recordButton.style('background-color', '#FFFFFF');  recordButton.style('border', 'none');  recordButton.style('padding', '8px 16px');  recordButton.style('font-weight', 'bold');  recordButton.mousePressed(recordGif);  // 2. DROPDOWNS  let labelPalette = createDiv("Palette");  labelPalette.position(uiX, uiY);  labelPalette.style('color', 'white');  labelPalette.style('font-family', 'monospace');    selector = createSelect();  selector.position(uiX + 80, uiY);  selector.option('Rainbow');  selector.option('Cyber');  selector.option('Fire');  selector.option('Ice');  selector.option('Toxic');  selector.style('width', '140px');  let labelBg = createDiv("Backgrnd");  labelBg.position(uiX, uiY + gap);  labelBg.style('color', 'white');  labelBg.style('font-family', 'monospace');    bgSelector = createSelect();  bgSelector.position(uiX + 80, uiY + gap);  bgSelector.option('Stars');  bgSelector.option('Ripples');  bgSelector.option('Grid');     bgSelector.option('Vortex');   bgSelector.option('None');  bgSelector.style('width', '140px');  // 3. TOGGLE BUTTON  dirButton = createButton('PULSE: EXPAND');  dirButton.position(uiX, uiY + gap * 2.2);  dirButton.style('width', '220px');  dirButton.style('background-color', '#FFF');  dirButton.style('border', 'none');  dirButton.style('padding', '5px');  dirButton.style('font-weight', 'bold');  dirButton.mousePressed(toggleDirection);  // 4. SLIDERS (Reorganized)  const makeSlider = (label, min, max, val, step, yPos) => {    let div = createDiv(label);    div.position(uiX, yPos);    div.style('color', 'white');    div.style('font-family', 'monospace');    div.style('font-size', '12px');    div.style('text-shadow', '1px 1px 2px black');    let sl = createSlider(min, max, val, step);    sl.position(uiX + 110, yPos);    sl.style('width', '120px');    return sl;  };  let startY = uiY + gap * 3.5;    // MOVED REACTION TO TOP  sliders.sensitivity = makeSlider('Reaction', 0.5, 4.0, params.sensitivity, 0.1, startY);    sliders.layers = makeSlider('Tunnel Depth', 1, 10, params.layers, 1, startY + gap);  sliders.offset = makeSlider('Spiral', 0, 0.5, params.offset, 0.01, startY + gap * 2);  sliders.sides = makeSlider('Polygons', 3, 12, params.sides, 1, startY + gap * 3);  sliders.symmetry = makeSlider('Symmetry', 1, 12, params.symmetry, 1, startY + gap * 4);  sliders.baseSize = makeSlider('Zoom', 50, 500, params.baseSize, 10, startY + gap * 5);  sliders.trails = makeSlider('Trails', 5, 100, params.trails, 5, startY + gap * 6);}function startAudioContext() {  userStartAudio();  mic.start();  fft.setInput(mic);  audioStarted = true;  startButton.html('LISTENING...');  startButton.style('background-color', '#FF0055');  startButton.style('color', 'white');}function recordGif() {  if (isRecording) return;  isRecording = true;  recordButton.html('RECORDING...');  recordButton.style('background-color', '#FF0000');  recordButton.style('color', '#FFFFFF');  saveGif('trippy_visuals', 3, { units: 'seconds', delay: 0 });  setTimeout(() => {    isRecording = false;    recordButton.html('RECORD GIF (3s)');    recordButton.style('background-color', '#FFFFFF');    recordButton.style('color', '#000000');  }, 3500);}function updateParams() {  // ReactionDir is updated via button, not slider  params.layers = sliders.layers.value();  params.offset = sliders.offset.value();  params.sides = sliders.sides.value();  params.symmetry = sliders.symmetry.value();  params.baseSize = sliders.baseSize.value();  params.sensitivity = sliders.sensitivity.value();  params.trails = sliders.trails.value();  params.colorMode = selector.value();  params.bgMode = bgSelector.value();}function windowResized() {  resizeCanvas(windowWidth, windowHeight);}