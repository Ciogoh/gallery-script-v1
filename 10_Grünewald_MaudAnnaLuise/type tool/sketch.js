let sizeSlider, fontColorPicker, boxColorPicker, workspaceBgPicker, saveBtn, resetBtn;let textContent = "click to type"; let currentRadius = 0, targetRadius = 0;let smoothBoxW = 0, smoothBoxH = 0;// --- Balanced Grid Constants ---const SIDEBAR_WIDTH = 250;const X_PAD = 20;const Y_START = 80;const SECTION_GAP = 110; const y1 = Y_START;                           const y2 = y1 + SECTION_GAP;                  const y3 = y2 + 55; const y4 = y3 + 60 + (y2 - (y1 + 25));        const y5 = y4 + SECTION_GAP;                  // --- State Variables ---let isFocused = false; let weightIndex = 5; let paletteHistory = [];let charScales = []; const WEIGHT_PERCENTS = [-0.065, -0.045, -0.03, -0.015, -0.005, 0, 0.02, 0.05, 0.08, 0.11, 0.14];function setup() {  pixelDensity(displayDensity());   createCanvas(windowWidth, windowHeight);  setupSidebar();  saveCurrentToHistory();    textAlign(LEFT, CENTER);   rectMode(CENTER);  textFont('Helvetica');}function draw() {  background(workspaceBgPicker.color());   handleKeyboardInput();   drawCanvasSidebar();  let availableWidth = (width - SIDEBAR_WIDTH) * 0.85;  let availableHeight = height * 0.8;  let intendedSize = sizeSlider.value();  textSize(intendedSize);    let naturalW = textWidth(textContent.toLowerCase()) || 1;  let finalFontSize = min(intendedSize, (availableWidth / naturalW) * intendedSize);  finalFontSize = min(finalFontSize, availableHeight / 1.4);  while (charScales.length < textContent.length) charScales.push(1.0);  renderTypography(centerX(), centerY(), finalFontSize);}// --- Visual Sidebar with Enhanced Instructions ---function drawCanvasSidebar() {  noStroke(); fill(30); rect(SIDEBAR_WIDTH / 2, height / 2, SIDEBAR_WIDTH, height);    fill(255); textSize(14); textStyle(BOLD); textAlign(LEFT, CENTER);  text("TYPE TOOL", X_PAD, 35);     // Section Titles  textStyle(BOLD); fill(170); textSize(10);  text("1. FONT SIZE", X_PAD, y1);   text("2. COLORS", X_PAD, y2);  text("3. THICKNESS", X_PAD, y4);  textStyle(NORMAL);    // Instructions  fill(100); textSize(8);  text("[SPACE TO SHUFFLE]", X_PAD + 65, y2);  // NEW: Clarity label for Keyboard Arrow control  text("[? ? ARROWS TO ADJUST]", X_PAD + 78, y4);    // Visual Sliders & Meters  fill(60); rect(SIDEBAR_WIDTH/2, y1 + 25, 200, 2, 1);  fill(255); circle(map(sizeSlider.value(), 20, 300, X_PAD, X_PAD + 200), y1 + 25, 10);  // Thickness Dot Meter  for(let i=0; i<=10; i++){    let dotX = X_PAD + (i * 20) + 5;    let isHovered = dist(mouseX, mouseY, dotX, y4 + 25) < 10;    fill(i === weightIndex ? 255 : (isHovered ? 120 : 60));    circle(dotX, y4 + 25, (i === weightIndex || isHovered) ? 6 : 3);  }  drawColorBox(X_PAD, y2 + 10, fontColorPicker.color());  drawColorBox(X_PAD + 70, y2 + 10, boxColorPicker.color());  drawColorBox(X_PAD + 140, y2 + 10, workspaceBgPicker.color());    fill(100); textSize(9); textStyle(BOLD);  text("HISTORY", X_PAD + 5, y3);   textStyle(NORMAL);  drawHistorySwatches(y3 + 22);    drawCanvasButton("EXPORT PNG", y5);  drawCanvasButton("RESET", y5 + 45);}function renderTypography(x, y, fSize) {  textSize(fSize);  let weightValue = fSize * WEIGHT_PERCENTS[weightIndex];  let charWidths = [];  let totalNaturalW = 0;  for (let char of textContent) {    let w = textWidth(char.toLowerCase());    charWidths.push(w); totalNaturalW += w;  }  let cumulativePush = 0;  let individualData = [];  let currentStartX = x - totalNaturalW / 2;  let runningX = currentStartX;  for (let i = 0; i < textContent.length; i++) {    let char = textContent[i];     let lowW = charWidths[i];    let isHovered = (mouseX > (runningX + cumulativePush) && mouseX < (runningX + cumulativePush + lowW) && mouseY > y - fSize/2 && mouseY < y + fSize/2);    charScales[i] = lerp(charScales[i] || 1, isHovered ? 1.4 : 1.0, 0.15);    let displayChar = isHovered ? char.toUpperCase() : char.toLowerCase();    let expandedW = textWidth(displayChar) * charScales[i];    let pushDelta = max(0, expandedW - lowW);    individualData.push({ char: displayChar, originalX: runningX, pushX: cumulativePush, scale: charScales[i], w: lowW });    cumulativePush += pushDelta; runningX += lowW;  }  let finalTotalW = totalNaturalW + cumulativePush;  smoothBoxW = lerp(smoothBoxW, finalTotalW + (fSize * 0.8), 0.2);  smoothBoxH = lerp(smoothBoxH, fSize * 1.4, 0.2);    if (isFocused) {    noFill(); stroke(boxColorPicker.color()); strokeWeight(1);    rect(x, y, smoothBoxW + 20, smoothBoxH + 20, currentRadius + 5);  }  noStroke(); fill(boxColorPicker.color());  targetRadius = (mouseX > x - smoothBoxW/2 && mouseX < x + smoothBoxW/2 && mouseY > y - smoothBoxH/2 && mouseY < y + smoothBoxH/2) ? smoothBoxH / 2 : 0;  currentRadius = lerp(currentRadius, targetRadius, 0.15);  rect(x, y, smoothBoxW, smoothBoxH, currentRadius);  let drawStartX = x - finalTotalW / 2;  textAlign(CENTER, CENTER);  for (let d of individualData) {    let centerX = drawStartX + (d.originalX - currentStartX) + d.pushX + (d.w / 2);    push(); translate(centerX, y); scale(d.scale);    if (weightValue > 0) {      strokeJoin(ROUND); strokeCap(ROUND);      stroke(fontColorPicker.color()); strokeWeight(weightValue / d.scale);      fill(fontColorPicker.color());      text(d.char, 0, 0);    } else if (weightValue < 0) {      strokeJoin(BEVEL); strokeCap(SQUARE);      noStroke(); fill(fontColorPicker.color()); text(d.char, 0, 0);      noFill(); stroke(boxColorPicker.color());      strokeWeight(abs(weightValue) / d.scale); text(d.char, 0, 0);    } else {      noStroke(); fill(fontColorPicker.color()); text(d.char, 0, 0);    }    pop();  }}function mousePressed() {   let x = centerX(), y = centerY();  if (mouseX > x - smoothBoxW/2 && mouseX < x + smoothBoxW/2 && mouseY > y - smoothBoxH/2 && mouseY < y + smoothBoxH/2) {    isFocused = true; return;  }   isFocused = false;   if (mouseY > y4 + 10 && mouseY < y4 + 40) {    for (let i = 0; i <= 10; i++) {      let dotX = X_PAD + (i * 20) + 5;      if (dist(mouseX, mouseY, dotX, y4 + 25) < 12) { weightIndex = i; return; }    }  }  let startY = y3 + 22;   if (mouseX > X_PAD && mouseX < SIDEBAR_WIDTH - X_PAD) {     for (let i = 1; i < 3; i++) {       let rowY = startY + (i * 20);       let idx = paletteHistory.length - 1 - i;      if (mouseY > rowY - 10 && mouseY < rowY + 10) { revertToPalette(idx); return; }     }   }}function keyPressed() {   if (!isFocused) {    if (key === ' ') generateRandomPalette();    else if (keyCode === LEFT_ARROW) weightIndex = max(0, weightIndex - 1);    else if (keyCode === RIGHT_ARROW) weightIndex = min(10, weightIndex + 1);  } else {    if (keyCode === BACKSPACE) textContent = textContent.slice(0, -1);     else if (key.length === 1 && keyCode !== SHIFT) textContent += key;   }}function setupSidebar() {  sizeSlider = createSlider(20, 300, 100, 10).position(X_PAD, y1 + 15).style('width', '200px').style('opacity', '0');  fontColorPicker = createColorPicker('#ffffff').position(X_PAD, y2 + 10).size(30, 30).style('opacity', '0').style('border', 'none');  boxColorPicker = createColorPicker('#000000').position(X_PAD + 70, y2 + 10).size(30, 30).style('opacity', '0').style('border', 'none');  workspaceBgPicker = createColorPicker('#f5f5f5').position(X_PAD + 140, y2 + 10).size(30, 30).style('opacity', '0').style('border', 'none');  saveBtn = createButton('').position(X_PAD, y5 - 18).size(200, 36).style('opacity', '0').mousePressed(() => {    let img = get(SIDEBAR_WIDTH, 0, width - SIDEBAR_WIDTH, height);    img.save('typography_design', 'png');  });  resetBtn = createButton('').position(X_PAD, y5 + 27).size(200, 36).style('opacity', '0').mousePressed(resetSettings);}function drawHistorySwatches(startY) {  let x = X_PAD + 5;   for (let i = 0; i < 3; i++) {    let idx = paletteHistory.length - 1 - i;    if (idx >= 0) {      let p = paletteHistory[idx]; let rowY = startY + (i * 20);      noStroke(); fill(p.bg); rect(x + 5, rowY, 10, 10, 1);      fill(p.box); rect(x + 20, rowY, 10, 10, 1);      fill(p.font); rect(x + 35, rowY, 10, 10, 1);      textSize(8.5);      if (i === 0) { fill(180); textStyle(BOLD); text("ACTIVE", x + 55, rowY); }       else { fill(80); textStyle(NORMAL); text("PREVIOUS", x + 55, rowY); }      textStyle(NORMAL);    }  }}function handleKeyboardInput() { if (keyIsDown(BACKSPACE) && isFocused && frameCount % 5 === 0) textContent = textContent.slice(0, -1); }function drawColorBox(x, y, col) { noStroke(); fill(col); rect(x + 15, y + 15, 30, 30, 3); }function drawCanvasButton(label, y) { fill(255); rect(SIDEBAR_WIDTH / 2, y, 200, 36, 2); fill(0); textAlign(CENTER, CENTER); textSize(10); textStyle(BOLD); text(label, SIDEBAR_WIDTH / 2, y); textStyle(NORMAL); }function centerX() { return (width + SIDEBAR_WIDTH) / 2; }function centerY() { return height / 2; }function generateRandomPalette() {   let boxR = random(255), boxG = random(255), boxB = random(255);   let luminance = (0.299 * boxR + 0.587 * boxG + 0.114 * boxB);   fontColorPicker.value(luminance > 128 ? "#000000" : "#ffffff");   boxColorPicker.value(color(boxR, boxG, boxB).toString('#rrggbb'));   saveCurrentToHistory(); }function saveCurrentToHistory() { paletteHistory.push({ font: fontColorPicker.value(), box: boxColorPicker.value(), bg: workspaceBgPicker.value() }); if (paletteHistory.length > 10) paletteHistory.shift(); }function revertToPalette(idx) { if (idx >= 0 && idx < paletteHistory.length) { let p = paletteHistory[idx]; fontColorPicker.value(p.font); boxColorPicker.value(p.box); workspaceBgPicker.value(p.bg); } }function resetSettings() { sizeSlider.value(100); weightIndex = 5; textContent = "click to type"; fontColorPicker.value("#ffffff"); boxColorPicker.value("#000000"); workspaceBgPicker.value("#f5f5f5"); paletteHistory = []; saveCurrentToHistory(); isFocused = false; }function windowResized() { resizeCanvas(windowWidth, windowHeight); }