let animLoop;
let gui;
let isRecording = false;

// Configuration object
const config = {
    // Layer 1
    layer1Pattern: 'Concentric Circles',
    layer1Speed: 1.0,
    layer1Color: '#ff71ce', // Hot pink
    
    // Layer 2
    layer2Pattern: 'Radial Lines',
    layer2Speed: 2.0,
    layer2Color: '#71efff', // Cyan
    
    // Animation controls
    complexity: 20,
    speedRatio: 2.0,
    
    // Visual effects
    chromaticAberration: 0,
    kaleidoscope: false,
    kaleidoscopeSegments: 6,
    
    // Style
    backgroundColor: '#000000',
    colorPalette: 'Vaporwave',
    strokeWeight: 1.5,
    
    // Canvas
    orientation: 'Horizontal',
    aspectRatio: '1:1',
    canvasSize: 800,
    radiusScale: 0.45, // Percentage of canvas size for pattern radius
    
    // Export
    duration: 3,
    fps: 30,
    exportGIF: function() {
        startRecording();
    }
};

// Color palettes presets
const palettes = {
    'Vaporwave': {
        bg: '#000000',
        layer1: '#ff71ce', // Hot pink
        layer2: '#71efff'  // Cyan
    },
    'Cyberpunk': {
        bg: '#000000',
        layer1: '#00ffff', // Cyan
        layer2: '#ff00ff'  // Magenta
    },
    'Monochrome': {
        bg: '#000000',
        layer1: '#ffffff', // White
        layer2: '#999999'  // Gray
    },
    'Neon Night': {
        bg: '#000000',
        layer1: '#00ff9d', // Neon green
        layer2: '#ff2476'  // Neon pink
    },
    'Infrared': {
        bg: '#000000',
        layer1: '#ff0000', // Red
        layer2: '#ff7f00'  // Orange
    },
    'Deep Ocean': {
        bg: '#001a33',
        layer1: '#00bfff', // Deep sky blue
        layer2: '#1affff'  // Aqua
    },
    'Sunset': {
        bg: '#1a0033',
        layer1: '#ff6b35', // Orange
        layer2: '#f7931e'  // Yellow-orange
    },
    'Toxic': {
        bg: '#0d0d0d',
        layer1: '#39ff14', // Neon green
        layer2: '#ccff00'  // Yellow-green
    }
};

// Calculate canvas dimensions based on orientation and aspect ratio
function getCanvasDimensions() {
    const ratios = {
        '1:1': [1, 1],
        '4:3': [4, 3],
        '3:4': [3, 4],
        '16:9': [16, 9],
        '9:16': [9, 16],
        '21:9': [21, 9],
        '9:21': [9, 21],
        '3:2': [3, 2],
        '2:3': [2, 3]
    };
    
    let [w, h] = ratios[config.aspectRatio] || [1, 1];
    
    // Apply orientation
    if (config.orientation === 'Vertical' && w > h) {
        [w, h] = [h, w]; // Swap to make vertical
    } else if (config.orientation === 'Horizontal' && h > w) {
        [w, h] = [h, w]; // Swap to make horizontal
    }
    
    // Calculate actual dimensions
    const aspectRatio = w / h;
    let width, height;
    
    if (aspectRatio >= 1) {
        // Landscape or square
        width = config.canvasSize;
        height = config.canvasSize / aspectRatio;
    } else {
        // Portrait
        height = config.canvasSize;
        width = config.canvasSize * aspectRatio;
    }
    
    return { width: Math.round(width), height: Math.round(height) };
}

function updateCanvasSize() {
    const { width, height } = getCanvasDimensions();
    resizeCanvas(width, height);
    console.log(`Canvas resized to ${width}x${height}`);
}

function setup() {
    // Create canvas with initial dimensions
    const { width, height } = getCanvasDimensions();
    createCanvas(width, height);
    
    // Set initial framerate from config
    frameRate(config.fps);
    
    // Initialize p5.createLoop WITHOUT GIF rendering
    try {
        animLoop = createLoop({
            duration: config.duration,
            gif: false  // Disable GIF completely at start
        });
        
        // Manually add gif configuration that we'll enable later
        animLoop.gif = {
            fileName: "moire_kinetic.gif",
            startLoop: 0,
            endLoop: 1,
            render: false,
            download: false,
            quality: 10
        };
        
        console.log('createLoop initialized successfully (GIF disabled)');
    } catch(e) {
        console.log("Error initializing createLoop:", e);
        // Fallback: create a simple loop object
        animLoop = {
            progress: function() {
                const t = (frameCount / (config.fps * config.duration)) % 1.0;
                return { theta: t, noise: 0 };
            },
            reset: function() { },
            duration: config.duration,
            gif: {
                render: false,
                download: false
            }
        };
    }
    
    // Setup GUI
    setupGUI();
    
    // Drawing settings
    strokeCap(SQUARE);
    noFill();
    
    showStatus('Ready to generate', 2000);
}

function draw() {
    // Use background color from config
    const bgColor = color(config.backgroundColor);
    background(bgColor);
    
    // Get loop progress (0.0 to 1.0)
    let theta = 0;
    if (animLoop && typeof animLoop.progress === 'function') {
        const progressData = animLoop.progress();
        theta = progressData.theta;
    } else {
        // Fallback: manual theta calculation
        theta = (frameCount / (config.fps * config.duration)) % 1.0;
    }
    
    translate(width / 2, height / 2);
    
    // Apply kaleidoscope effect if enabled
    if (config.kaleidoscope) {
        applyKaleidoscope(theta);
    } else {
        renderNormalMode(theta);
    }
}

function renderNormalMode(theta) {
    const angle1 = theta * TWO_PI * config.layer1Speed;
    const angle2 = theta * TWO_PI * config.layer2Speed;
    
    // Layer 1
    push();
    rotate(angle1);
    drawPattern(config.layer1Pattern, config.layer1Color, 0);
    pop();
    
    // Chromatic aberration on layer 2
    if (config.chromaticAberration > 0) {
        const offset = config.chromaticAberration * 3;
        
        // Red channel
        push();
        translate(-offset, 0);
        rotate(angle2);
        drawPattern(config.layer2Pattern, '#ff0000', 0.3);
        pop();
        
        // Green channel
        push();
        rotate(angle2);
        drawPattern(config.layer2Pattern, '#00ff00', 0.3);
        pop();
        
        // Blue channel
        push();
        translate(offset, 0);
        rotate(angle2);
        drawPattern(config.layer2Pattern, '#0000ff', 0.3);
        pop();
    } else {
        // Normal layer 2
        push();
        rotate(angle2);
        drawPattern(config.layer2Pattern, config.layer2Color, 0);
        pop();
    }
    
    // Additional layers for complexity
    if (config.complexity > 30) {
        push();
        rotate(-angle1 * 0.5);
        drawPattern(config.layer1Pattern, config.layer1Color, 0.5);
        pop();
    }
}

function applyKaleidoscope(theta) {
    const segments = config.kaleidoscopeSegments;
    const angle1 = theta * TWO_PI * config.layer1Speed;
    const angle2 = theta * TWO_PI * config.layer2Speed;
    
    for (let i = 0; i < segments; i++) {
        push();
        rotate((TWO_PI / segments) * i);
        
        // Mirror every other segment
        if (i % 2 === 1) {
            scale(-1, 1);
        }
        
        // Layer 1
        push();
        rotate(angle1);
        drawPattern(config.layer1Pattern, config.layer1Color, 0.3);
        pop();
        
        // Layer 2
        push();
        rotate(angle2);
        drawPattern(config.layer2Pattern, config.layer2Color, 0.3);
        pop();
        
        pop();
    }
}

function drawPattern(patternType, hexColor, alphaMultiplier = 0) {
    const col = color(hexColor);
    const alpha = alphaMultiplier > 0 ? 255 * alphaMultiplier : 255;
    stroke(red(col), green(col), blue(col), alpha);
    strokeWeight(config.strokeWeight);
    
    // Use the smaller dimension and apply radius scale
    const maxRadius = min(width, height) * config.radiusScale;
    const count = config.complexity;
    
    switch(patternType) {
        case 'Concentric Circles':
            drawConcentricCircles(maxRadius, count);
            break;
        case 'Radial Lines':
            drawRadialLines(maxRadius, count);
            break;
        case 'Square Grid':
            drawSquareGrid(maxRadius, count);
            break;
        case 'Spiral':
            drawSpiral(maxRadius, count);
            break;
        case 'Hexagonal':
            drawHexagonal(maxRadius, count);
            break;
        case 'Triangular':
            drawTriangular(maxRadius, count);
            break;
        case 'Wave Grid':
            drawWaveGrid(maxRadius, count);
            break;
    }
}

function drawConcentricCircles(maxRadius, count) {
    for (let i = 1; i <= count; i++) {
        const r = (maxRadius / count) * i;
        circle(0, 0, r * 2);
    }
}

function drawRadialLines(maxRadius, count) {
    for (let i = 0; i < count; i++) {
        const angle = (TWO_PI / count) * i;
        const x = cos(angle) * maxRadius;
        const y = sin(angle) * maxRadius;
        line(0, 0, x, y);
    }
}

function drawSquareGrid(maxRadius, count) {
    for (let i = 1; i <= count; i++) {
        const size = (maxRadius * 2 / count) * i;
        rectMode(CENTER);
        square(0, 0, size);
    }
}

function drawSpiral(maxRadius, count) {
    beginShape();
    const points = count * 20;
    for (let i = 0; i < points; i++) {
        const angle = (i / points) * TWO_PI * count;
        const r = (i / points) * maxRadius;
        const x = cos(angle) * r;
        const y = sin(angle) * r;
        vertex(x, y);
    }
    endShape();
}

function drawHexagonal(maxRadius, count) {
    for (let ring = 1; ring <= count; ring++) {
        const r = (maxRadius / count) * ring;
        beginShape();
        for (let i = 0; i <= 6; i++) {
            const angle = (TWO_PI / 6) * i;
            const x = cos(angle) * r;
            const y = sin(angle) * r;
            vertex(x, y);
        }
        endShape(CLOSE);
    }
}

function drawTriangular(maxRadius, count) {
    for (let i = 1; i <= count; i++) {
        const r = (maxRadius / count) * i;
        beginShape();
        for (let j = 0; j <= 3; j++) {
            const angle = (TWO_PI / 3) * j - HALF_PI;
            const x = cos(angle) * r;
            const y = sin(angle) * r;
            vertex(x, y);
        }
        endShape(CLOSE);
    }
}

function drawWaveGrid(maxRadius, count) {
    const spacing = maxRadius * 2 / count;
    for (let i = -count; i <= count; i++) {
        beginShape();
        for (let j = -count; j <= count; j++) {
            const x = j * spacing;
            const y = i * spacing + sin(j * 0.5) * spacing * 0.3;
            vertex(x, y);
        }
        endShape();
    }
    
    for (let i = -count; i <= count; i++) {
        beginShape();
        for (let j = -count; j <= count; j++) {
            const x = i * spacing + sin(j * 0.5) * spacing * 0.3;
            const y = j * spacing;
            vertex(x, y);
        }
        endShape();
    }
}

function setupGUI() {
    gui = new lil.GUI({ title: 'MOIRE CONTROLS' });
    
    const patternTypes = ['Concentric Circles', 'Radial Lines', 'Square Grid', 'Spiral', 'Hexagonal', 'Triangular', 'Wave Grid'];
    
    // Layer 1 folder
    const layer1Folder = gui.addFolder('Layer 1');
    layer1Folder.add(config, 'layer1Pattern', patternTypes).name('Pattern');
    layer1Folder.add(config, 'layer1Speed', -5, 5, 0.1).name('Speed');
    layer1Folder.addColor(config, 'layer1Color').name('Color');
    
    // Layer 2 folder
    const layer2Folder = gui.addFolder('Layer 2');
    layer2Folder.add(config, 'layer2Pattern', patternTypes).name('Pattern');
    layer2Folder.add(config, 'layer2Speed', -5, 5, 0.1).name('Speed');
    layer2Folder.addColor(config, 'layer2Color').name('Color');
    
    // Animation folder
    const animFolder = gui.addFolder('Animation');
    animFolder.add(config, 'complexity', 5, 50, 1).name('Complexity');
    animFolder.add(config, 'speedRatio', 0.1, 5, 0.1).name('Speed Ratio').onChange((value) => {
        config.layer2Speed = config.layer1Speed * value;
        gui.controllersRecursive().forEach(c => c.updateDisplay());
    });
    
    // Effects folder
    const effectsFolder = gui.addFolder('Effects');
    effectsFolder.add(config, 'chromaticAberration', 0, 10, 0.1).name('Chromatic Aberr.');
    effectsFolder.add(config, 'kaleidoscope').name('Kaleidoscope Mode (K)');
    effectsFolder.add(config, 'kaleidoscopeSegments', 3, 12, 1).name('K-Segments');
    
    // Style folder
    const styleFolder = gui.addFolder('Style');
    styleFolder.add(config, 'colorPalette', Object.keys(palettes)).name('Palette').onChange((paletteName) => {
        // Apply palette colors
        const palette = palettes[paletteName];
        config.backgroundColor = palette.bg;
        config.layer1Color = palette.layer1;
        config.layer2Color = palette.layer2;
        // Update all GUI controllers to reflect new colors
        gui.controllersRecursive().forEach(c => c.updateDisplay());
        showStatus(`Palette: ${paletteName}`, 2000);
    });
    styleFolder.addColor(config, 'backgroundColor').name('Background Color');
    styleFolder.add(config, 'strokeWeight', 0.5, 5, 0.1).name('Stroke Weight');
    
    // Canvas folder
    const canvasFolder = gui.addFolder('Canvas');
    
    // Aspect ratio controller (will be recreated on orientation change)
    let aspectRatioController;
    
    function getAvailableRatios() {
        const allRatios = {
            'Square': ['1:1'],
            'Horizontal': ['1:1', '4:3', '16:9', '21:9', '3:2'],
            'Vertical': ['1:1', '3:4', '9:16', '9:21', '2:3']
        };
        return allRatios[config.orientation] || ['1:1'];
    }
    
    function updateAspectRatioOptions() {
        const availableRatios = getAvailableRatios();
        
        // Check if current ratio is valid for new orientation
        if (!availableRatios.includes(config.aspectRatio)) {
            config.aspectRatio = '1:1'; // Reset to square if invalid
        }
        
        // Remove old controller if exists
        if (aspectRatioController) {
            canvasFolder.remove(aspectRatioController);
        }
        
        // Add new controller with filtered options
        aspectRatioController = canvasFolder.add(config, 'aspectRatio', availableRatios).name('Aspect Ratio').onChange(() => {
            updateCanvasSize();
            showStatus('Aspect ratio updated', 2000);
        });
    }
    
    canvasFolder.add(config, 'orientation', ['Horizontal', 'Vertical']).name('Orientation').onChange(() => {
        updateAspectRatioOptions();
        updateCanvasSize();
        showStatus('Canvas orientation updated', 2000);
    });
    
    // Initialize aspect ratio controller
    updateAspectRatioOptions();
    
    canvasFolder.add(config, 'canvasSize', 400, 1600, 50).name('Size (px)').onChange(() => {
        updateCanvasSize();
        showStatus('Canvas size updated', 2000);
    });
    
    canvasFolder.add(config, 'radiusScale', 0.2, 0.8, 0.01).name('Pattern Radius').onChange(() => {
        showStatus('Pattern radius updated', 1000);
    });
    
    // Export folder
    const exportFolder = gui.addFolder('Export');
    exportFolder.add(config, 'duration', 1, 10, 0.5).name('Duration (sec)').onChange((value) => {
        animLoop.duration = value;
    });
    exportFolder.add(config, 'fps', 15, 60, 1).name('FPS').onChange((value) => {
        // Update framerate in real-time
        frameRate(value);
        console.log(`Framerate updated to ${value} fps`);
    });
    exportFolder.add(config, 'exportGIF').name('RECORD & EXPORT (R)');
    exportFolder.add({
        saveFrame: function() {
            saveCanvas('moire-frame', 'png');
            showStatus('Frame saved!', 2000);
        }
    }, 'saveFrame').name('Save Frame (S)');
    
    // Actions folder - Keyboard shortcuts
    const actionsFolder = gui.addFolder('Actions');
    actionsFolder.add({
        togglePause: function() {
            if (isLooping()) {
                noLoop();
                showStatus('Paused', 2000);
            } else {
                loop();
                showStatus('Playing', 2000);
            }
        }
    }, 'togglePause').name('Pause/Play (P)');
    
    // Open folders
    layer1Folder.open();
    layer2Folder.open();
    animFolder.open();
}

function startRecording() {
    console.log('startRecording called');
    
    if (isRecording) {
        console.log('Already recording');
        showStatus('Already recording!', 2000);
        return;
    }
    
    if (!animLoop) {
        console.log('ERROR: animLoop not initialized');
        showStatus('Animation loop not available', 3000);
        return;
    }
    
    console.log('Starting new recording...');
    console.log(`Duration: ${config.duration}s, FPS: ${config.fps}`);
    isRecording = true;
    showStatus('Initializing GIF recorder...', 0);
    
    try {
        // p5.createLoop renders at canvas framerate, so set it
        frameRate(config.fps);
        
        // Reinitialize createLoop with GIF enabled
        animLoop = createLoop({
            duration: config.duration,
            gif: {
                fileName: "moire_kinetic.gif",
                startLoop: 0,
                endLoop: 1,
                render: true,
                download: true,
                quality: 10
            }
        });
        
        console.log(`GIF recording started - ${config.fps} fps`);
        showStatus('Recording GIF...', 0);
        
        const totalFrames = config.duration * config.fps;
        let framesCaptured = 0;
        
        // Monitor recording progress
        const checkInterval = setInterval(() => {
            framesCaptured++;
            const progress = Math.min(Math.round((framesCaptured / totalFrames) * 100), 100);
            showStatus(`Recording: ${progress}%`, 0);
            
            if (framesCaptured >= totalFrames + 30) { // Extra time for processing
                clearInterval(checkInterval);
                console.log('Recording should be complete');
                showStatus('Processing GIF...', 0);
                
                setTimeout(() => {
                    showStatus('GIF downloaded!', 3000);
                    isRecording = false;
                    
                    // Framerate stays at config.fps (user's choice)
                    
                    // Reinitialize without GIF for normal playback
                    animLoop = createLoop({
                        duration: config.duration,
                        gif: false
                    });
                    animLoop.gif = {
                        render: false,
                        download: false
                    };
                }, 2000);
            }
        }, 1000 / config.fps);
        
    } catch(e) {
        console.error('Error starting GIF recording:', e);
        showStatus('GIF export failed', 3000);
        isRecording = false;
    }
}

function showStatus(message, duration) {
    const status = select('#status');
    if (status) {
        status.html(message);
        status.addClass('show');
        
        if (duration > 0) {
            setTimeout(() => {
                status.removeClass('show');
            }, duration);
        }
    }
}

// Keyboard shortcuts
function keyPressed() {
    if (key === 'r' || key === 'R') {
        startRecording();
    } else if (key === 's' || key === 'S') {
        saveCanvas('moire-frame', 'png');
        showStatus('Frame saved!', 2000);
    } else if (key === 'k' || key === 'K') {
        config.kaleidoscope = !config.kaleidoscope;
        gui.controllersRecursive().forEach(c => c.updateDisplay());
    } else if (key === 'p' || key === 'P') {
        if (isLooping()) {
            noLoop();
            showStatus('Paused', 2000);
        } else {
            loop();
            showStatus('Playing', 2000);
        }
    }
}