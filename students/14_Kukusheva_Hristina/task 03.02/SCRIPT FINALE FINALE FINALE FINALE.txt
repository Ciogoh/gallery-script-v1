// --- CONFIGURAZIONE ---
const ROOM_W = 400;
const ROOM_H = 300;
const DUNGEON_SIZE = 5;
const DOOR_W = 60;

// --- FADE-IN ---
let fade = 255;

// --- PLAYER ---
let player = {
  x: ROOM_W / 2,
  y: ROOM_H / 2,
  size: 20,
  speed: 3,
  ammo: 15,
  maxAmmo: 40,
  hearts: 3,
  maxHearts: 3,
  invulTime: 0
};

// --- POSIZIONE STANZA ---
let roomX = 2;
let roomY = 2;

// --- STATO PORTE ---
let roomLocked = false;

// --- STANZE COMPLETATE ---
let roomCleared = [];

// --- MOSTRI ---
let monsters = {};

// --- PROIETTILI ---
let bullets = [];

// --- PICKUP ---
let ammoPickups = {};
let heartPickups = {};

// --- GAME OVER ---
let gameOver = false;

// --- ACCENDINO 3D ---
let accendinoModel;
let accendinoGraphics;
let lighterTexture;

// --- PRELOAD ---
function preload() {
  accendinoModel = loadModel("accendino.obj", true);
}

function setup() {
  createCanvas(ROOM_W, ROOM_H);
  noSmooth();

  accendinoGraphics = createGraphics(40, 40, WEBGL);

  initRooms();
  generateMonstersAndPickups();
  updateRoomLockedState();
}

function draw() {
  background(20);

  drawRoom();
  if (!gameOver) {
    movePlayer();
    updateBullets();
    updateMonsters();
    checkPlayerMonsterCollision();
    checkPickups();
  }
  drawPlayer();
  drawBullets();
  drawMonsters();
  drawMinimap();
  drawHUD();

  if (fade > 0) {
    fade -= 4;
    fill(0, fade);
    rect(0, 0, width, height);
  }

  if (gameOver) drawGameOver();

  if (player.invulTime > 0) player.invulTime--;
}

//////////////////////////////////////////////////////////
// INIZIALIZZAZIONE STANZE, MOSTRI, PICKUP
//////////////////////////////////////////////////////////

function initRooms() {
  for (let y = 0; y < DUNGEON_SIZE; y++) {
    roomCleared[y] = [];
    for (let x = 0; x < DUNGEON_SIZE; x++) {
      roomCleared[y][x] = false;
    }
  }
}

function generateMonstersAndPickups() {
  for (let y = 0; y < DUNGEON_SIZE; y++) {
    for (let x = 0; x < DUNGEON_SIZE; x++) {
      let key = `${x},${y}`;

      monsters[key] = [];
      let count = floor(random(0, 3));
      for (let i = 0; i < count; i++) {
        monsters[key].push({
          x: random(50, ROOM_W - 50),
          y: random(50, ROOM_H - 50),
          size: 20,
          hp: 2,
          alive: true,
          vx: 0,
          vy: 0
        });
      }

      ammoPickups[key] = [];
      if (random() < 0.5) {
        ammoPickups[key].push({
          x: random(40, ROOM_W - 60),
          y: random(40, ROOM_H - 60),
          w: 16,
          h: 12,
          active: true
        });
      }

      heartPickups[key] = [];
    }
  }
}

//////////////////////////////////////////////////////////
// STATO STANZA
//////////////////////////////////////////////////////////

function updateRoomLockedState() {
  let key = `${roomX},${roomY}`;
  let mons = monsters[key] || [];
  roomLocked = mons.some(m => m.alive);

  if (!roomLocked) {
    roomCleared[roomY][roomX] = true;
  }
}

//////////////////////////////////////////////////////////
// MOVIMENTO PLAYER
//////////////////////////////////////////////////////////

function movePlayer() {
  let oldX = roomX;
  let oldY = roomY;

  if (keyIsDown(65)) player.x -= player.speed;
  if (keyIsDown(68)) player.x += player.speed;
  if (keyIsDown(87)) player.y -= player.speed;
  if (keyIsDown(83)) player.y += player.speed;

  if (!roomLocked &&
      player.x < 0 &&
      player.y > ROOM_H/2 - DOOR_W/2 &&
      player.y < ROOM_H/2 + DOOR_W/2) {
    if (roomX > 0) {
      roomX--;
      player.x = ROOM_W - player.size;
    }
  }

  if (!roomLocked &&
      player.x > ROOM_W - player.size &&
      player.y > ROOM_H/2 - DOOR_W/2 &&
      player.y < ROOM_H/2 + DOOR_W/2) {
    if (roomX < DUNGEON_SIZE - 1) {
      roomX++;
      player.x = 0;
    }
  }

  if (!roomLocked &&
      player.y < 0 &&
      player.x > ROOM_W/2 - DOOR_W/2 &&
      player.x < ROOM_W/2 + DOOR_W/2) {
    if (roomY > 0) {
      roomY--;
      player.y = ROOM_H - player.size;
    }
  }

  if (!roomLocked &&
      player.y > ROOM_H - player.size &&
      player.x > ROOM_W/2 - DOOR_W/2 &&
      player.x < ROOM_W/2 + DOOR_W/2) {
    if (roomY < DUNGEON_SIZE - 1) {
      roomY++;
      player.y = 0;
    }
  }

  player.x = constrain(player.x, 0, ROOM_W - player.size);
  player.y = constrain(player.y, 0, ROOM_H - player.size);

  if (roomX !== oldX || roomY !== oldY) {
    updateRoomLockedState();
  }
}

//////////////////////////////////////////////////////////
// SPARO
//////////////////////////////////////////////////////////

function keyPressed() {
  if (gameOver) return;

  let dx = 0, dy = 0;

  if (keyCode === LEFT_ARROW) dx = -1;
  if (keyCode === RIGHT_ARROW) dx = 1;
  if (keyCode === UP_ARROW) dy = -1;
  if (keyCode === DOWN_ARROW) dy = 1;

  if (dx === 0 && dy === 0) return;
  if (player.ammo <= 0) return;

  bullets.push({
    x: player.x + player.size / 2,
    y: player.y + player.size / 2,
    size: 6,
    dx: dx * 5,
    dy: dy * 5,
    roomX: roomX,
    roomY: roomY
  });

  player.ammo = max(0, player.ammo - 1);
}

//////////////////////////////////////////////////////////
// PROIETTILI
//////////////////////////////////////////////////////////

function updateBullets() {
  for (let b of bullets) {
    if (b.roomX !== roomX || b.roomY !== roomY) continue;
    b.x += b.dx;
    b.y += b.dy;
  }

  bullets = bullets.filter(b =>
    b.x > -10 && b.x < ROOM_W + 10 &&
    b.y > -10 && b.y < ROOM_H + 10
  );

  let key = `${roomX},${roomY}`;
  let mons = monsters[key] || [];

  for (let b of bullets) {
    if (b.roomX !== roomX || b.roomY !== roomY) continue;

    for (let m of mons) {
      if (!m.alive) continue;

      if (rectOverlap(b.x, b.y, b.size, b.size, m.x, m.y, m.size, m.size)) {
        m.hp--;
        b.x = -9999;

        if (m.hp <= 0) {
          m.alive = false;

          if (random() < 0.4) {
            heartPickups[key].push({
              x: m.x + m.size/2,
              y: m.y + m.size/2,
              size: 14,
              active: true
            });
          }
        }
      }
    }
  }

  bullets = bullets.filter(b => b.x > -9000);

  updateRoomLockedState();
}

function drawBullets() {
  fill(220, 50, 50);
  for (let b of bullets) {
    if (b.roomX === roomX && b.roomY === roomY)
      rect(b.x, b.y, b.size, b.size);
  }
}

//////////////////////////////////////////////////////////
// MOSTRI
//////////////////////////////////////////////////////////

function updateMonsters() {
  let key = `${roomX},${roomY}`;
  let mons = monsters[key] || [];

  for (let m of mons) {
    if (!m.alive) continue;

    if (random() < 0.02) {
      m.vx = random(-1.5, 1.5);
      m.vy = random(-1.5, 1.5);
    }

    m.x += m.vx || 0;
    m.y += m.vy || 0;

    m.x = constrain(m.x, 20, ROOM_W - 20 - m.size);
    m.y = constrain(m.y, 20, ROOM_H - 20 - m.size);
  }
}

function drawMonsters() {
  let key = `${roomX},${roomY}`;
  let mons = monsters[key] || [];

  for (let m of mons) {
    if (!m.alive) continue;
    fill(50, 200, 80);
    rect(m.x, m.y, m.size, m.size);
  }
}

//////////////////////////////////////////////////////////
// COLLISIONE PLAYER - MOSTRI
//////////////////////////////////////////////////////////

function checkPlayerMonsterCollision() {
  if (player.invulTime > 0) return;

  let key = `${roomX},${roomY}`;
  let mons = monsters[key] || [];

  for (let m of mons) {
    if (!m.alive) continue;

    if (rectOverlap(player.x, player.y, player.size, player.size,
                    m.x, m.y, m.size, m.size)) {
      player.hearts--;
      player.invulTime = 60;

      if (player.hearts <= 0) {
        gameOver = true;
      }
      break;
    }
  }
}

//////////////////////////////////////////////////////////
// PICKUP
//////////////////////////////////////////////////////////

function checkPickups() {
  let key = `${roomX},${roomY}`;

  let ammoP = ammoPickups[key] || [];
  for (let a of ammoP) {
    if (!a.active) continue;

    if (rectOverlap(player.x, player.y, player.size, player.size,
                    a.x, a.y, a.w, a.h)) {
      a.active = false;
      let gain = floor(random(3, 8));
      player.ammo = min(player.maxAmmo, player.ammo + gain);
    }
  }

  let heartsP = heartPickups[key] || [];
  for (let h of heartsP) {
    if (!h.active) continue;

    if (rectOverlap(player.x, player.y, player.size, player.size,
                    h.x - h.size/2, h.y - h.size/2, h.size, h.size)) {
      h.active = false;
      if (player.hearts < player.maxHearts) player.hearts++;
    }
  }
}

//////////////////////////////////////////////////////////
// DISEGNO PLAYER
//////////////////////////////////////////////////////////

function drawPlayer() {
  if (player.invulTime > 0 && frameCount % 6 < 3) return;

  fill(200, 100, 50);
  rect(player.x, player.y, player.size, player.size);
}

//////////////////////////////////////////////////////////
// STANZA + PORTE + PICKUP
//////////////////////////////////////////////////////////

function drawRoom() {
  fill(40);
  rect(0, 0, ROOM_W, ROOM_H);

  stroke(120);
  strokeWeight(4);
  noFill();
  rect(2, 2, ROOM_W - 4, ROOM_H - 4);
  noStroke();

  fill(60);
  randomSeed(roomX * 100 + roomY * 10);
  for (let i = 0; i < (roomX + roomY + 1) * 3; i++) {
    let px = floor(random(20, ROOM_W - 20));
    let py = floor(random(20, ROOM_H - 20));
    rect(px, py, 6, 6);
  }

  fill(40);

  rect(0, ROOM_H/2 - DOOR_W/2, 4, DOOR_W);
  rect(ROOM_W - 4, ROOM_H/2 - DOOR_W/2, 4, DOOR_W);
  rect(ROOM_W/2 - DOOR_W/2, 0, DOOR_W, 4);
  rect(ROOM_W/2 - DOOR_W/2, ROOM_H - 4, DOOR_W, 4);

  let key = `${roomX},${roomY}`;

  let ammoP = ammoPickups[key] || [];
  for (let a of ammoP) {
    if (!a.active) continue;
    fill(230, 210, 40);
    rect(a.x, a.y, a.w, a.h);
  }

  let heartsP = heartPickups[key] || [];
  for (let h of heartsP) {
    if (!h.active) continue;
    fill(220, 70, 70);
    rect(h.x - h.size/2, h.y - h.size/2, h.size, h.size);
  }
}

//////////////////////////////////////////////////////////
// MINIMAPPA
//////////////////////////////////////////////////////////

function drawMinimap() {
  const mapSize = 100;
  const cell = mapSize / DUNGEON_SIZE;

  push();
  translate(width - mapSize - 10, 10);

  stroke(255);
  strokeWeight(2);
  fill(0, 120);
  rect(0, 0, mapSize, mapSize);
  noStroke();

  for (let y = 0; y < DUNGEON_SIZE; y++) {
    for (let x = 0; x < DUNGEON_SIZE; x++) {

      if (roomCleared[y][x]) {
        fill(150);
      } else {
        fill(80);
      }

      rect(x * cell, y * cell, cell, cell);

      if (roomCleared[y][x]) {
        fill(0, 255, 0);
        textAlign(CENTER, CENTER);
        textSize(10);
        text("✔", x * cell + cell/2, y * cell + cell/2);
      }
    }
  }

  noFill();
  stroke(255, 220, 0);
  strokeWeight(2);
  rect(roomX * cell, roomY * cell, cell, cell);

  pop();
}

//////////////////////////////////////////////////////////
// HUD + ACCENDINO 3D
//////////////////////////////////////////////////////////
function drawHUD() {
  // --- SLOT ACCENDINO ---
  noFill();
  stroke(200);
  strokeWeight(2);
  rect(10, 10, 40, 40);

  accendinoGraphics.push();
  accendinoGraphics.clear();

  // LUCI
  accendinoGraphics.ambientLight(200);
  accendinoGraphics.directionalLight(255, 255, 255, 0.5, -1, -0.5);

  // TRUCCO: genera normali artificiali
  accendinoGraphics.normalMaterial();

  // ORA applica materiale metallico
  accendinoGraphics.specularMaterial(220);
  accendinoGraphics.shininess(100);

  // SCALA MIGLIORATA
  accendinoGraphics.scale(0.35);        // più piccolo
  accendinoGraphics.scale(0.65, 0.55, 1); // meno largo e meno alto

  // ORIENTAMENTO
  accendinoGraphics.rotateX(-0.3);
  accendinoGraphics.rotateY(frameCount * 0.01);

  accendinoGraphics.model(accendinoModel);
  accendinoGraphics.pop();

  image(accendinoGraphics, 10, 10);

  // --- MUNIZIONI ---
  fill(255);
  noStroke();
  textSize(12);
  text("Ammo: " + player.ammo + "/" + player.maxAmmo, 60, 12);

  // --- CUORI ---
  let heartSize = 12;
  for (let i = 0; i < player.maxHearts; i++) {
    if (i < player.hearts) fill(220, 60, 60);
    else fill(80);
    rect(60 + i * (heartSize + 4), 28, heartSize, heartSize);
  }
}




//////////////////////////////////////////////////////////
// GAME OVER
//////////////////////////////////////////////////////////

function drawGameOver() {
  fill(0, 180);
  rect(0, 0, width, height);
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(24);
  text("GAME OVER", width / 2, height / 2);
}

//////////////////////////////////////////////////////////
// COLLISIONE RETTANGOLI
//////////////////////////////////////////////////////////

function rectOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
  return !(
    x1 + w1 < x2 ||
    x1 > x2 + w2 ||
    y1 + h1 < y2 ||
    y1 > y2 + h2
  );
}
