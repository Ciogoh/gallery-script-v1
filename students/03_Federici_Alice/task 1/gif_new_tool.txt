let particles = [];let NUM_PARTICLES = 100;let amplitude = 60;   let spacing = 20;      let speed = 0.04;      let shapeSelector, moveSelector, directionSelector, countSlider, countLabel;let alignCheck, linesSlider, linesLabel, trailCheck;let waveAmpSlider, waveAmpLabel, sizeSlider, sizeLabel, speedSlider, colorPicker;let recordButton;let currentShape = 'Square';let currentMove = 'Harmonic';let currentDir = 'Down'; let isAligned = true; let numLines = 1;let hasTrail = true;let recordingCountdown = -1;let globalSpeedMultiplier = 1;let globalSizeMultiplier = 1; const sidebarWidth = 240;class Particle {    constructor(index) {        this.index = index;        this.resetPosition();        this.phaseShift = 0;        this.basePhase = this.index * 0.2;         this.baseVelocity = random(1.5, 3.5);        this.baseSize = 6;    }    resetPosition() {        this.x = random(sidebarWidth + 50, width - 50);        this.y = random(0, height);    }    update() {        let t = frameCount * speed * globalSpeedMultiplier;        let v = this.baseVelocity * globalSpeedMultiplier;        if (currentDir === 'Down') {            this.y += v;            if (this.y > height + 50) this.y = -50;        } else if (currentDir === 'Up') {            this.y -= v;            if (this.y < -50) this.y = height + 50;        } else if (currentDir === 'Right') {            this.x += v;            if (this.x > width + 50) this.x = sidebarWidth - 50;        } else if (currentDir === 'Left') {            this.x -= v;            if (this.x < sidebarWidth - 50) this.x = width + 50;        }        if (isAligned) {            let colIndex = this.index % numLines;            let totalWidth = (numLines - 1) * spacing;            if (currentDir === 'Down' || currentDir === 'Up') {                let startX = sidebarWidth + (width - sidebarWidth - totalWidth) / 2;                this.targetX = startX + (colIndex * spacing);            } else {                let startY = (height - totalWidth) / 2;                this.targetY = startY + (colIndex * spacing);            }        }        let finalPhase = this.basePhase + this.phaseShift;        let osc = 0;        if (currentMove === 'Harmonic') {            osc = sin(t + finalPhase) * amplitude + sin(t * 1.6 + this.index) * (amplitude * 0.25);        } else if (currentMove === 'Wave') {            let ref = (currentDir === 'Down' || currentDir === 'Up') ? this.y : this.x;            osc = sin(ref * 0.01 + finalPhase) * amplitude;        }        this.offset = osc;    }    display() {        let s = this.baseSize * globalSizeMultiplier;        let c = colorPicker.color();        push();        if (currentDir === 'Down' || currentDir === 'Up') {            if (isAligned) this.x = lerp(this.x, this.targetX, 0.1);            translate(this.x + this.offset, this.y);        } else {            if (isAligned) this.y = lerp(this.y, this.targetY, 0.1);            translate(this.x, this.y + this.offset);        }        fill(c);        noStroke();        if (currentShape === 'Square') { rectMode(CENTER); rect(0, 0, s, s); }         else if (currentShape === 'Circle') { ellipse(0, 0, s); }         else if (currentShape === 'Triangle') { let h = s * 0.866; triangle(0, -h/2, -s/2, h/2, s/2, h/2); }         else if (currentShape === 'Line') {             stroke(c); strokeWeight(s / 2);            if (currentDir === 'Right' || currentDir === 'Left') line(-s * 1.5, 0, s * 1.5, 0);            else line(0, -s * 1.5, 0, s * 1.5);        }        pop();    }}function setup() {    createCanvas(windowWidth, windowHeight);    createSidebar();    updateParticleCount();}function draw() {    if (hasTrail) background(10, 40);     else background(10);    for (let p of particles) { p.update(); p.display(); }    drawSidebarUI();    if (recordingCountdown > 0) {        fill(255, 50, 50); noStroke();        ellipse(width - 30, 30, 15, 15);        recordingCountdown--;    }}function createSidebar() {    let x = 25, y = 30;    const labelStyle = 'color: #bbb; font-family: "Helvetica", sans-serif; font-size: 9px; letter-spacing: 0.05em; margin-bottom: 5px;';    const inputStyle = 'background: #222; color: #fff; border: 1px solid #333; padding: 5px; border-radius: 3px; font-size: 10px; width: 190px;';    let title = createElement('h2', 'A GIF TOOL');    title.style('color: #fff; font-family: monospace; font-size: 14px; margin-bottom: 30px; border-bottom: 1px solid #333; padding-bottom: 10px;');    title.position(x, 10);    recordButton = createButton('EXPORT GIF');    recordButton.position(x, y + 40);    recordButton.style('background', '#fff; border:none; width: 190px; padding:8px; cursor:pointer; font-weight:bold; font-size:10px; border-radius:2px;');    recordButton.mousePressed(startGifRecording);    y += 100;    countLabel = createLabel('DENSITY', x, y, labelStyle);    countSlider = createSlider(1, 500, NUM_PARTICLES, 1);    countSlider.position(x, y + 15);    countSlider.style('width', '190px');    countSlider.input(updateParticleCount);    y += 50;    trailCheck = createCheckbox(' TRAIL', true);    trailCheck.position(x, y);    trailCheck.style('color', '#888'); trailCheck.style('font-size', '10px');    trailCheck.changed(() => hasTrail = trailCheck.checked());    y += 25;    alignCheck = createCheckbox(' ALIGN', true);    alignCheck.position(x, y);    alignCheck.style('color', '#888'); alignCheck.style('font-size', '10px');    alignCheck.changed(() => isAligned = alignCheck.checked());    y += 50;    linesLabel = createLabel('COLUMNS / ROWS', x, y, labelStyle);    linesSlider = createSlider(1, 20, 1, 1);    linesSlider.position(x, y + 15);    linesSlider.style('width', '190px');    linesSlider.input(() => { numLines = linesSlider.value(); });    y += 50;    createLabel('DIRECTION', x, y, labelStyle);    directionSelector = createSelect();    directionSelector.position(x, y + 15);    directionSelector.style(inputStyle);    directionSelector.option('Down'); directionSelector.option('Up'); directionSelector.option('Left'); directionSelector.option('Right');    directionSelector.changed(() => { currentDir = directionSelector.value(); particles.forEach(p => p.resetPosition()); });    y += 50;    waveAmpLabel = createLabel('AMPLITUDE', x, y, labelStyle);    waveAmpSlider = createSlider(0, 200, 60, 1);    waveAmpSlider.position(x, y + 15);    waveAmpSlider.style('width', '190px');    waveAmpSlider.input(() => { amplitude = waveAmpSlider.value(); });    y += 50;    sizeLabel = createLabel('SIZE', x, y, labelStyle);    sizeSlider = createSlider(0.1, 8, 1, 0.1);    sizeSlider.position(x, y + 15);    sizeSlider.style('width', '190px');    sizeSlider.input(() => {         globalSizeMultiplier = sizeSlider.value();        sizeLabel.html('SIZE');     });    // --- AGGIUNTA SPEED SLIDER ---    y += 50;    let speedLabel = createLabel('SPEED', x, y, labelStyle);    speedSlider = createSlider(0.1, 4, 1, 0.1);    speedSlider.position(x, y + 15);    speedSlider.style('width', '190px');    speedSlider.input(() => {         globalSpeedMultiplier = speedSlider.value();    });    y += 50;    createLabel('GEOMETRY', x, y, labelStyle);    shapeSelector = createSelect();    shapeSelector.position(x, y + 15);    shapeSelector.style(inputStyle);    shapeSelector.option('Square'); shapeSelector.option('Circle'); shapeSelector.option('Triangle'); shapeSelector.option('Line');    shapeSelector.changed(() => currentShape = shapeSelector.value());    y += 50;    createLabel('COLOR', x, y, labelStyle);    colorPicker = createColorPicker('#ffffff');    colorPicker.position(x, y + 15);    colorPicker.style('width', '190px'); colorPicker.style('border', 'none'); colorPicker.style('background', 'none');}function drawSidebarUI() {    push();    noStroke();    fill(15);    rect(0, 0, sidebarWidth, height);    stroke(255, 10);    line(sidebarWidth, 0, sidebarWidth, height);    pop();}function keyPressed() { if (key === 's' || key === 'S') startGifRecording(); }function startGifRecording() { recordingCountdown = 300; saveGif('myFlow_Export', 5); }function updateParticleCount() {    let target = countSlider.value();    if (particles.length < target) { for (let i = particles.length; i < target; i++) particles.push(new Particle(i)); }     else { particles.splice(target); }}function createLabel(txt, x, y, style) { let l = createElement('span', txt); l.style(style); l.position(x, y); return l; }function windowResized() { resizeCanvas(windowWidth, windowHeight); }