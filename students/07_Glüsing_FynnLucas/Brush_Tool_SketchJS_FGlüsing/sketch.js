let evilEraser;let pg; // Game State Enum: 'MENU', 'PLAYING', 'GAMEOVER'let gameState = 'MENU';let gameStartTime;let gameDuration = 120000; let hasGameStarted = false; // UI Elementslet colorPicker, sliderSize;let btnBrush, btnBucket, btnRestart; let currentTool = 'BRUSH'; let startScreenDiv, toolbarDiv, gameOverDiv; // Gallery Storagelet sessionGallery = []; // --- CUSTOM SVG ICONS ---// We define them as HTML strings to inject into buttonsconst ICONS = {  BRUSH: `<svg viewBox="0 0 24 24" class="icon"><path d="M20.71 5.63l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-3.12 3.12-1.93-1.91-1.41 1.41 1.42 1.42L3 16.25V21h4.75l8.92-8.92 1.42 1.42 1.41-1.41-1.92-1.92 3.12-3.12c.4-.4.4-1.03.01-1.42zM5.21 19H5v-.21l8.92-8.92 2.12 2.12L5.21 19z"/></svg>`,  BUCKET: `<svg viewBox="0 0 24 24" class="icon"><path d="M16.56 12l1.95-2.13-9.98-9.33-9 8.64 3.99 4.41c.42-.48 1.05-.73 1.69-.67.24.02.48.09.7.19l-2.3-2.52 6.36-6.11 7.23 7.89-1.42 1.55c-.29-.11-.59-.16-.9-.16-.54 0-1.05.2-1.44.57l-1.63-1.78-1.57 1.47 1.63 1.78c-.73 1.15-.49 2.72.63 3.63.49.4 1.09.59 1.69.59.39 0 .78-.08 1.15-.25l2.4 2.63 1.57-1.47-2.4-2.63c.53-1 .44-2.22-.29-3.12-.4-.49-1.01-.76-1.63-.76-.08 0-.17.01-.25.02l1.52-1.66z"/></svg>`,  RESTART: `<svg viewBox="0 0 24 24" class="icon"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>`,  SAVE: `<svg viewBox="0 0 24 24" class="icon"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>`,  SKULL: `<svg viewBox="0 0 24 24" class="icon" style="width:50px; height:50px; fill:#ff5555;"><path d="M12 2c-4.42 0-8 3.58-8 8 0 4.42 8 12 8 12s8-7.58 8-12c0-4.42-3.58-8-8-8zm0 4c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm0 14c-1.67 0-3.14-.85-4-2.15 1.05-1.28 2.38-2.25 4-2.25s2.95.98 4 2.25c-.86 1.3-2.33 2.15-4 2.15zm2.5-9c-.83 0-1.5-.67-1.5-1.5S13.67 8 14.5 8s1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm-5 0c-.83 0-1.5-.67-1.5-1.5S10.67 8 11.5 8s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>`};const prompts = [  "A friend",  "A Professor or Assistant",  "Your favorite place in Bolzano",  "Unibz graffiti",  "A good eraser (The Hero)",  "The Dolomites at sunset",  "A plate of Canederli",  "The Museion building",  "…tzi the Iceman",  "A bicycle in Walterplatz",  "A futuristic treehouse",  "A scary monster",  "A slice of Speck",  "A flying car",  "Your dream house"];let currentPrompt = "";const TOOLBAR_HEIGHT = 80;function setup() {  pixelDensity(1);   createCanvas(windowWidth, windowHeight);    addStyles();  pg = createGraphics(windowWidth, windowHeight);  pg.pixelDensity(1);  pg.background(255);     currentPrompt = random(prompts);  createToolbar();  createStartScreen();    evilEraser = new Eraser();  cursor(ARROW);}// --- SCREEN CREATION FUNCTIONS ---function createStartScreen() {  startScreenDiv = createDiv('');  startScreenDiv.id('start-screen');    let content = createDiv('').parent(startScreenDiv).class('start-content');    // Custom Icon + Title  let titleRow = createDiv('').parent(content).style('display:flex; justify-content:center; align-items:center; gap:15px;');  createDiv(ICONS.SKULL).parent(titleRow);  createElement('h1', 'EVIL ERASER').parent(titleRow);    createElement('p', 'You have 2 minutes to draw:').parent(content);    let promptBox = createDiv(currentPrompt).parent(content).class('prompt-box');    let startBtn = createButton("I'M READY").parent(content);  startBtn.class('start-btn');  startBtn.mousePressed(() => {    gameState = 'PLAYING';    startScreenDiv.hide();    toolbarDiv.style('display', 'flex');     cursor(CROSS);  });}function createGameOverScreen() {  gameOverDiv = createDiv('');  gameOverDiv.id('game-over-screen');    let content = createDiv('').parent(gameOverDiv).class('game-over-content');    createElement('h1', "TIME'S UP!").parent(content);  createDiv('Topic: ' + currentPrompt).parent(content).style('color', '#aaa').style('margin-bottom', '20px');    let btnRow = createDiv('').parent(content).class('btn-row');    // Download Button with Icon  let dlBtn = createButton(ICONS.SAVE + ' Save Art').parent(btnRow);  dlBtn.class('action-btn save-btn');  dlBtn.mousePressed(() => {    pg.save('My_Art_' + currentPrompt + '.png');  });  // Restart Button with Icon  let restartBtn = createButton(ICONS.RESTART + ' New Round').parent(btnRow);  restartBtn.class('action-btn restart-btn');  restartBtn.mousePressed(() => {    gameOverDiv.remove();     resetGame();   });  // Gallery  if (sessionGallery.length > 0) {    createDiv('Previous Drawings:').parent(content).class('gallery-title');    let galleryContainer = createDiv('').parent(content).class('gallery-container');        for (let i = sessionGallery.length - 1; i >= 0; i--) {      let item = sessionGallery[i];      let card = createDiv('').parent(galleryContainer).class('gallery-card');            item.img.loadPixels();      let imgData = item.img.canvas.toDataURL();      let domImg = createImg(imgData, item.prompt).parent(card);      domImg.class('gallery-thumb');      createDiv(item.prompt).parent(card).class('gallery-caption');    }  }}function createToolbar() {  toolbarDiv = createDiv('');  toolbarDiv.id('toolbar');  toolbarDiv.style('display', 'none');     let group1 = createDiv('').parent(toolbarDiv).class('tool-group');  colorPicker = createColorPicker('#000000');  colorPicker.parent(group1);    let group2 = createDiv('').parent(toolbarDiv).class('tool-group');  sliderSize = createSlider(1, 50, 5);  sliderSize.parent(group2);  sliderSize.class('my-slider');  createDiv('').parent(toolbarDiv).class('spacer');  let group3 = createDiv('').parent(toolbarDiv).class('tool-group');    // Brush Button with SVG  btnBrush = createButton(ICONS.BRUSH);  setupButton(btnBrush, 'BRUSH', group3);    // Bucket Button with SVG  btnBucket = createButton(ICONS.BUCKET);  setupButton(btnBucket, 'BUCKET', group3);    let group4 = createDiv('').parent(toolbarDiv).class('tool-group');    // Restart Button with SVG  btnRestart = createButton(ICONS.RESTART);  btnRestart.parent(group4);  btnRestart.class('tool-btn danger'); // No 'wide-btn', just icon  btnRestart.mousePressed(() => {    resetGame();  });    updateUI();}function setupButton(btn, toolName, parent) {  btn.parent(parent);  btn.class('tool-btn');  btn.mousePressed(() => {    currentTool = toolName;    updateUI();  });}function updateUI() {  if (currentTool === 'BRUSH') btnBrush.addClass('active'); else btnBrush.removeClass('active');  if (currentTool === 'BUCKET') btnBucket.addClass('active'); else btnBucket.removeClass('active');}function draw() {  if (gameState === 'MENU' || gameState === 'GAMEOVER') {    background(220);    image(pg, 0, 0);    if (gameState === 'GAMEOVER') {      fill(0, 150);      rect(0, 0, width, height);    }    return;  }  background(220);   image(pg, 0, 0);  let remainingTime = gameDuration;  if (hasGameStarted && gameState === 'PLAYING') {    remainingTime = gameDuration - (millis() - gameStartTime);    if (remainingTime <= 0) endGame();  }  if (gameState === 'PLAYING' && mouseIsPressed) {    if (mouseY < height - TOOLBAR_HEIGHT) {      handleDrawing();    }  }  evilEraser.update();  evilEraser.show();    drawPromptHeader();  drawTimer(remainingTime);}function drawPromptHeader() {  push();  fill(0, 150);  noStroke();  rect(0, 0, width, 40);  fill(255);  textAlign(CENTER, CENTER);  textSize(16);  text("Draw: " + currentPrompt, width/2, 20);  pop();}function handleDrawing() {  if (!hasGameStarted) {    hasGameStarted = true;    gameStartTime = millis();    evilEraser.wakeUp();  }  if (currentTool === 'BRUSH') {    pg.stroke(colorPicker.color());    pg.strokeWeight(sliderSize.value());    pg.strokeCap(ROUND);    pg.strokeJoin(ROUND);    pg.line(pmouseX, pmouseY, mouseX, mouseY);        let d = dist(mouseX, mouseY, evilEraser.pos.x, evilEraser.pos.y);    if (d < 50) evilEraser.takeDamage();  }}function mousePressed() {  if (gameState === 'PLAYING' && mouseY < height - TOOLBAR_HEIGHT && currentTool === 'BUCKET') {    if (!hasGameStarted) {        hasGameStarted = true;        gameStartTime = millis();        evilEraser.wakeUp();    }    pg.loadPixels();    let c = colorPicker.color();    let fillColor = [red(c), green(c), blue(c), 255];     floodFill(mouseX, mouseY, fillColor);  }}function endGame() {  gameState = 'GAMEOVER';  cursor(ARROW);  toolbarDiv.style('display', 'none');   let artSnapshot = pg.get();   sessionGallery.push({    img: artSnapshot,    prompt: currentPrompt  });    createGameOverScreen();}function resetGame() {  pg.background(255);  hasGameStarted = false;    evilEraser = new Eraser();   currentPrompt = random(prompts);  select('.prompt-box').html(currentPrompt);   gameState = 'MENU';  startScreenDiv.show();   toolbarDiv.style('display', 'none');     cursor(ARROW);}function drawTimer(ms) {  if (ms < 0) ms = 0;  let totalSeconds = floor(ms / 1000);  let min = floor(totalSeconds / 60);  let sec = totalSeconds % 60;  let timeString = nf(min, 2) + ":" + nf(sec, 2);    push();  fill(50); noStroke();  rect(width - 100, 50, 90, 40, 10);   fill(255); textSize(20); textAlign(CENTER, CENTER); textStyle(BOLD);  text(timeString, width - 55, 72);  pop();}function floodFill(x, y, newColor) {  let startColor = getPixelColor(x, y);  if (colorsMatch(startColor, newColor)) return;  let stack = [[x, y]];  while (stack.length > 0) {    let current = stack.pop();    let cx = current[0]; let cy = current[1];    if (cx < 0 || cx >= pg.width || cy < 0 || cy >= pg.height) continue;    let offset = (cy * pg.width + cx) * 4;    if (matchesPixelAtIndex(offset, startColor)) {      pg.pixels[offset] = newColor[0]; pg.pixels[offset+1] = newColor[1];      pg.pixels[offset+2] = newColor[2]; pg.pixels[offset+3] = 255;      stack.push([cx + 1, cy]); stack.push([cx - 1, cy]);      stack.push([cx, cy + 1]); stack.push([cx, cy - 1]);    }  }  pg.updatePixels(); }function getPixelColor(x, y) {  let idx = 4 * (y * pg.width + x);  return [pg.pixels[idx], pg.pixels[idx+1], pg.pixels[idx+2], pg.pixels[idx+3]];}function matchesPixelAtIndex(idx, c) {  return pg.pixels[idx] === c[0] && pg.pixels[idx+1] === c[1] && pg.pixels[idx+2] === c[2];}function colorsMatch(c1, c2) { return c1[0]===c2[0] && c1[1]===c2[1] && c1[2]===c2[2]; }function windowResized() { resizeCanvas(windowWidth, windowHeight); }// --- EVIL ERASER CLASS ---class Eraser {  constructor() {    this.pos = createVector(width / 2, height - 40);     this.target = createVector(width/2, height/2);    this.prevPos = this.pos.copy();    this.state = 'SLEEPING';     this.timer = 0;    this.waitTime = 60;     this.health = 100;    this.scale = 0.5;    this.hitTimer = 0;   }    wakeUp() {    this.state = 'ENTERING';    this.target = this.getNewTarget();  }    getNewTarget() {      let m = 50;       return createVector(random(m, width - m), random(m + 40, height - TOOLBAR_HEIGHT - m));  }  takeDamage() {    if (this.state !== 'STUNNED' && this.state !== 'RECOVERING' && this.state !== 'SLEEPING') {       this.health -= 5;        this.hitTimer = 5;        this.scale = map(this.health, 0, 100, 0.4, 0.8);       if (this.health <= 0) {         this.state = 'STUNNED';         this.timer = 0;       }    }  }  update() {    this.prevPos = this.pos.copy();    if (this.state === 'SLEEPING') return;    if (this.state === 'ENTERING') {      this.scale = lerp(this.scale, 0.8, 0.05);      this.pos.lerp(this.target, 0.08);      if (p5.Vector.dist(this.pos, this.target) < 10) this.state = 'WAITING';    }     else if (this.state === 'WAITING') {      this.pos.x += random(-2, 2);      this.pos.y += random(-2, 2);      this.timer++;      if (this.timer > this.waitTime) {        this.state = 'MOVING';        this.target = this.getNewTarget();        this.timer = 0;        this.waitTime = random(30, 90);       }    }     else if (this.state === 'MOVING') {      this.pos.lerp(this.target, 0.15);       this.rubOut();       if (p5.Vector.dist(this.pos, this.target) < 10) this.state = 'WAITING';    }     else if (this.state === 'STUNNED') {      this.timer++;      if (this.timer > 180) this.state = 'RECOVERING';    }     else if (this.state === 'RECOVERING') {      this.health += 2;      this.scale = map(this.health, 0, 100, 0.4, 0.8);      if (this.health >= 100) {        this.health = 100;        this.state = 'WAITING';        this.waitTime = 20;       }    }        if (this.hitTimer > 0) this.hitTimer--;    if (this.state !== 'SLEEPING' && this.state !== 'ENTERING') {        this.pos.x = constrain(this.pos.x, 30, width - 30);        this.pos.y = constrain(this.pos.y, 70, height - TOOLBAR_HEIGHT - 30);     }  }  rubOut() {    if (this.state === 'ENTERING') return;    let thickness = random(30, 50) * this.scale;    pg.stroke(255);     pg.strokeWeight(thickness);    pg.strokeCap(ROUND);    pg.strokeJoin(ROUND);    pg.line(this.prevPos.x, this.prevPos.y, this.pos.x, this.pos.y);        if (random(1) < 0.3) {      pg.noStroke();      pg.fill(150);       let r = 20 * this.scale;      pg.rect(this.pos.x + random(-r, r), this.pos.y + random(-r, r), random(2, 5), random(2, 5));    }  }  show() {    push();    translate(this.pos.x, this.pos.y);    scale(this.scale);         if (this.state === 'SLEEPING') rotate(0);    else if (this.state === 'STUNNED') rotate(frameCount * 0.1);    else if (this.state === 'MOVING' || this.state === 'ENTERING') {        let angle = p5.Vector.sub(this.target, this.pos).heading();        rotate(angle + PI/2);    } else rotate(random(-0.1, 0.1));         stroke(0); strokeWeight(1);    if (this.hitTimer > 0) fill(255, 0, 0); else fill('#ff99aa');         rectMode(CENTER);    rect(0, 0, 40, 60, 5);         if (this.state === 'SLEEPING') {      fill(0); noStroke();      rect(-10, -5, 10, 2); rect(10, -5, 10, 2); ellipse(0, 15, 5, 5);      if (frameCount % 60 < 30) { textSize(20); text("z", 25, -20); }    } else if (this.state === 'STUNNED') {      stroke(0); strokeWeight(2);      line(-14, -14, -6, -6); line(-14, -6, -6, -14);      line(6, -14, 14, -6); line(6, -6, 14, -14);      noFill(); arc(0, 15, 20, 10, PI, 0);     } else {      noStroke(); fill(255);       ellipse(-10, -10, 12, 12); ellipse(10, -10, 12, 12);       fill(0); ellipse(-10, -10, 4, 4); ellipse(10, -10, 4, 4);       stroke(0); strokeWeight(3); noFill();      line(-16, -20, -4, -12); line(16, -20, 4, -12);         strokeWeight(1); fill(255); rect(0, 15, 20, 8); line(0, 11, 0, 19);    }    pop();        if (this.state === 'STUNNED') {       push(); translate(this.pos.x, this.pos.y - 50);       noStroke(); fill(255, 200, 0);       ellipse(cos(frameCount * 0.2) * 30, sin(frameCount * 0.2) * 10, 10, 10);       pop();    }  }}// --- CSS STYLING ---function addStyles() {  let css = `    body { margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; }        .icon { width: 24px; height: 24px; fill: currentColor; }    /* Start Screen */    #start-screen {      position: fixed; top: 0; left: 0; width: 100%; height: 100%;      background: radial-gradient(circle, #333, #000);      display: flex; justify-content: center; align-items: center;      z-index: 20; color: white;    }    .start-content { text-align: center; }    .start-content h1 { font-size: 4rem; color: #ff5555; margin: 0; text-shadow: 3px 3px 0 #000; }    .start-content p { font-size: 1.5rem; margin-bottom: 20px; color: #ccc; }        .prompt-box {      background: white; color: black; padding: 20px 40px;      font-size: 2rem; font-weight: bold; border-radius: 10px;      margin: 20px auto 40px auto; max-width: 80%;      box-shadow: 0 0 20px #ff5555; transform: rotate(-2deg);    }        .start-btn {      padding: 20px 50px; font-size: 24px; font-weight: bold;      background: #4CAF50; color: white; border: none; border-radius: 50px;      cursor: pointer; transition: 0.2s; box-shadow: 0 5px 0 #2E7D32;    }    .start-btn:hover { transform: scale(1.1); box-shadow: 0 8px 0 #2E7D32; }        /* Game Over Screen */    #game-over-screen {      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);      width: 80%; height: 85%;      background: #222; border-radius: 20px;      display: flex; flex-direction: column; align-items: center; justify-content: flex-start;      z-index: 30; color: white; padding: 30px;      box-shadow: 0 0 50px rgba(0,0,0,0.8);    }    .game-over-content { width: 100%; text-align: center; display:flex; flex-direction:column; align-items:center; height:100%; }    .game-over-content h1 { font-size: 3rem; margin: 0; color: #ff5555; }        .btn-row { display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center; }    .action-btn {      padding: 15px 30px; font-size: 18px; border: none; border-radius: 8px; cursor: pointer; color: white;      display: flex; align-items: center; gap: 10px;    }    .save-btn { background: #2196F3; } .save-btn:hover { background: #1976D2; }    .restart-btn { background: #4CAF50; } .restart-btn:hover { background: #388E3C; }        /* Gallery */    .gallery-title { font-size: 1.2rem; margin-bottom: 10px; align-self: flex-start; width: 100%; border-bottom: 1px solid #555; padding-bottom:5px; text-align:left;}    .gallery-container {      width: 100%; flex-grow: 1; overflow-y: auto;      display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));      gap: 15px; padding: 10px; background: #333; border-radius: 10px;    }    .gallery-card { background: #444; padding: 10px; border-radius: 5px; text-align: center; }    .gallery-thumb { width: 100%; height: auto; border: 1px solid #666; display: block; background:white; }    .gallery-caption { font-size: 0.9rem; margin-top: 5px; color: #ddd; word-wrap: break-word; }    /* Toolbar */    #toolbar {      position: fixed; bottom: 0; left: 0; width: 100%; height: 80px;      background: #222; display: flex; flex-direction: row;      align-items: center; justify-content: center; gap: 20px;      box-shadow: 0 -2px 10px rgba(0,0,0,0.5); z-index: 10;    }    .tool-group { display: flex; align-items: center; gap: 10px; }    .spacer { width: 100px; height: 1px; }         .tool-btn {      width: 50px; height: 50px; border: none; border-radius: 12px;      background: #333; color: white; cursor: pointer;      display: flex; justify-content: center; align-items: center;      transition: 0.2s; box-shadow: 0 4px 0 #111;    }        .tool-btn:hover { background: #444; transform: translateY(-2px); box-shadow: 0 6px 0 #111; }    .tool-btn:active { transform: translateY(2px); box-shadow: 0 0 0 #111; }    .tool-btn.active { background: #4CAF50; box-shadow: 0 4px 0 #2E7D32; }    .tool-btn.danger { background: #d32f2f; color: white; }    .tool-btn.danger:hover { background: #b71c1c; }        input[type=color] { width: 50px; height: 50px; border: none; padding: 0; background: none; cursor: pointer; }  `;  let style = createElement('style', css);}