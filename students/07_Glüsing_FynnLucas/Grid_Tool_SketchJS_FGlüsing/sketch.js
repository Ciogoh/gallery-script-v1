let img;let buffer; let resolutionSlider;let txtInput;let uploadBtn;let saveBtn;let resetViewBtn;// View Variableslet zoom = 1.0;let panX = 0;let panY = 0;let isDragging = false;// Toggleslet twoToneCheckbox;let modeCheckbox; let invertCheckbox; // Color Controlslet colorCtrlDiv; let textColorPicker;let bgColorPicker; // Paletteslet sortedLetterPalette = ""; let sortedWordPalette = [];   function setup() {  createCanvas(windowWidth, windowHeight);  background(20);  // --- INJECT CSS FOR CLEAN UI ---  // This makes the UI look professional without cluttering the JS with inline styles  let css = `    body { font-family: 'Inter', 'Segoe UI', sans-serif; background: #000; overflow: hidden; }        /* LEFT SIDEBAR */    .sidebar {      position: fixed; top: 0; left: 0; height: 100vh; width: 280px;      background: #111; border-right: 1px solid #222;      padding: 20px; overflow-y: auto; z-index: 1000;      box-shadow: 5px 0 20px rgba(0,0,0,0.5);    }        /* HEADERS */    h1 { color: #fff; font-size: 16px; margin: 0 0 25px 0; font-weight: 700; letter-spacing: 0.5px; opacity: 0.9; }    h2 { color: #666; font-size: 10px; margin: 25px 0 10px 0; font-weight: 700; letter-spacing: 1px; text-transform: uppercase; border-bottom: 1px solid #222; padding-bottom: 5px; }        /* INPUTS & CONTROLS */    .control-group { margin-bottom: 15px; }        /* Custom File Input Wrapper */    input[type=file] { color: #888; font-size: 12px; }        input[type=range] { width: 100%; accent-color: #fff; cursor: pointer; }        input[type=text] {      width: 100%; background: #222; border: 1px solid #333;      color: #eee; padding: 10px; border-radius: 6px; font-size: 13px;      outline: none; transition: border 0.2s; box-sizing: border-box;    }    input[type=text]:focus { border-color: #555; }        /* Checkboxes */    label { color: #ccc; font-size: 13px; display: flex; align-items: center; gap: 10px; cursor: pointer; user-select: none; }    input[type=checkbox] { accent-color: #fff; width: 14px; height: 14px; cursor: pointer; }        /* Color Pickers */    input[type=color] {      width: 100%; height: 35px; border: none; background: none; cursor: pointer; padding: 0;    }        /* INFO TEXT */    .info { color: #555; font-size: 11px; line-height: 1.4; margin-top: 5px; }        /* BUTTONS */    .btn-main {      background: #fff; color: #000; border: none; padding: 12px;      width: 100%; border-radius: 6px; font-weight: 600; cursor: pointer;      font-size: 13px; transition: transform 0.1s, background 0.2s;    }    .btn-main:hover { background: #eee; }    .btn-main:active { transform: scale(0.98); }        .btn-secondary {      background: #222; color: #ccc; border: 1px solid #333; padding: 8px 12px;      border-radius: 6px; font-size: 11px; cursor: pointer; transition: background 0.2s;    }    .btn-secondary:hover { background: #333; color: #fff; }    /* RIGHT HUD (View Controls) */    .hud-right {      position: fixed; top: 20px; right: 20px;      background: rgba(17, 17, 17, 0.9); backdrop-filter: blur(5px);      border: 1px solid #222; padding: 15px; border-radius: 8px;      text-align: center; z-index: 1000; width: 160px;    }  `;  createElement('style', css);  // ==================================================  // 1. LEFT SIDEBAR CONTAINER  // ==================================================  let sidebar = createDiv('');  sidebar.class('sidebar');  createDiv('<h1>Texture Rasterizer</h1>').parent(sidebar);  // --- SECTION: IMAGE ---  createDiv('<h2>Source Image</h2>').parent(sidebar);    uploadBtn = createFileInput(handleFile);  uploadBtn.parent(sidebar);  uploadBtn.class('control-group');  // --- SECTION: MODE ---  createDiv('<h2>Raster Mode</h2>').parent(sidebar);    let modeLabel = createElement('label', '');  modeLabel.parent(sidebar);  modeCheckbox = createCheckbox('', false);  modeCheckbox.parent(modeLabel);  modeCheckbox.changed(updateBuffer);  createSpan('Flow Mode (Words)').parent(modeLabel);    createDiv('¥ "Words" are separated by spaces.<br>¥ Works best with varied word lengths.')    .class('info')    .parent(sidebar);  // --- SECTION: SETTINGS ---  createDiv('<h2>Settings</h2>').parent(sidebar);    // Resolution  createDiv('<label>Size / Spacing</label>').parent(sidebar).style('margin-bottom','5px');  resolutionSlider = createSlider(2, 80, 8, 1);   resolutionSlider.parent(sidebar);  resolutionSlider.input(updateBuffer);     // Invert  let invLabel = createElement('label', '');  invLabel.parent(sidebar);  invLabel.style('margin-top','15px');  invertCheckbox = createCheckbox('', false);  invertCheckbox.parent(invLabel);  invertCheckbox.changed(updateBuffer);  createSpan('Invert Density (Dark background)').parent(invLabel);  // --- SECTION: COLORS ---  createDiv('<h2>Colors</h2>').parent(sidebar);    // Background  createDiv('<label>Background</label>').parent(sidebar).style('margin-bottom','5px');  bgColorPicker = createColorPicker('#111111');   bgColorPicker.parent(sidebar);  bgColorPicker.input(redraw);    // Two Tone  let ttLabel = createElement('label', '');  ttLabel.parent(sidebar);  ttLabel.style('margin-top','15px');  twoToneCheckbox = createCheckbox('', false);  twoToneCheckbox.parent(ttLabel);    createSpan('Two-Tone Text').parent(ttLabel);    // Hidden Text Color Picker  colorCtrlDiv = createDiv('');  colorCtrlDiv.parent(sidebar);  colorCtrlDiv.style('display', 'none');   colorCtrlDiv.style('margin-top', '10px');    createDiv('<label>Text Color</label>').parent(colorCtrlDiv).style('margin-bottom','5px');  textColorPicker = createColorPicker('#ffffff');  textColorPicker.parent(colorCtrlDiv);  textColorPicker.input(updateBuffer);     twoToneCheckbox.changed(() => {    if(twoToneCheckbox.checked()) {      colorCtrlDiv.style('display', 'block');    } else {      colorCtrlDiv.style('display', 'none');    }    updateBuffer();  });  // --- SECTION: TEXT ---  createDiv('<h2>Content</h2>').parent(sidebar);  txtInput = createInput("Type here to customize pixels");   txtInput.parent(sidebar);  txtInput.input(() => {    calculatePalettes();    updateBuffer();  });  // --- SECTION: EXPORT ---  createDiv('<h2>Export</h2>').parent(sidebar);  saveBtn = createButton('Download High-Res PNG');  saveBtn.class('btn-main');  saveBtn.parent(sidebar);  saveBtn.mousePressed(saveHighRes);  // ==================================================  // 2. RIGHT HUD (View Controls)  // ==================================================  let hud = createDiv('');  hud.class('hud-right');  createDiv('<span style="color:#fff; font-size:12px; font-weight:bold;">View Controls</span>').parent(hud);    createDiv('Scroll to Zoom<br>Drag to Pan')    .class('info')    .parent(hud)    .style('margin-bottom', '10px');  resetViewBtn = createButton('Reset View');  resetViewBtn.class('btn-secondary');  resetViewBtn.parent(hud);  resetViewBtn.mousePressed(resetView);  // Initialize Logic  calculatePalettes();}// --- VIEW LOGIC ---function resetView() {  zoom = 1.0;  panX = 0;  panY = 0;  redraw();}function isMouseOverUI() {  if (mouseX < 290) return true; // Left Sidebar width + padding  if (mouseX > width - 200 && mouseY < 150) return true; // Right HUD  return false;}function mouseWheel(event) {  if (isMouseOverUI()) return;   let e = event.delta;  let zoomFactor = 0.05;  if (e < 0) zoom += zoomFactor;  else zoom -= zoomFactor;  zoom = constrain(zoom, 0.1, 20); // Allow deep zoom  redraw();  return false;}function mousePressed() {  if (!isMouseOverUI()) isDragging = true;}function mouseReleased() {  isDragging = false;}function mouseDragged() {  if (isDragging) {    panX += movedX;    panY += movedY;    redraw();  }}// --- DRAW LOOP ---function draw() {  background(bgColorPicker.value());  if (buffer) {    push();    translate(width/2, height/2);    translate(panX, panY);    scale(zoom);    translate(-width/2, -height/2);        let aspect = buffer.width / buffer.height;    let fitW = width - 300; // Account for sidebar    if (fitW < 100) fitW = width; // Safety fallback        let fitH = fitW / aspect;        // Fit logic to ensure image is visible initially    if (fitH > height - 100) {      fitH = height - 100;      fitW = fitH * aspect;    }        // Center logic accounting for sidebar offset slightly    let drawX = (width + 280 - fitW) / 2; // Offset center by sidebar width    let drawY = (height - fitH) / 2;        if (zoom === 1.0 && panX === 0 && panY === 0) {       // Only center precisely on reset       // Otherwise let user pan freely    } else {       // For general drawing, just center on 0,0 relative to transformations       drawX = (width - fitW) / 2;    }    image(buffer, drawX, drawY, fitW, fitH);    pop();  } else {    fill(50);    textAlign(CENTER, CENTER);    textSize(14);    text("Upload an image in the sidebar to begin", (width + 280)/2, height/2);  }}// --- RENDER ENGINE ---function updateBuffer() {  if (!img) return;    if (sortedLetterPalette.length === 0 && sortedWordPalette.length === 0) {    calculatePalettes();  }  if (!buffer || buffer.width !== img.width || buffer.height !== img.height) {    buffer = createGraphics(img.width, img.height);  }  let isTwoTone = twoToneCheckbox.checked();  let isWordMode = modeCheckbox.checked();  let isInvert = invertCheckbox.checked();  let step = resolutionSlider.value();  buffer.clear();   buffer.noStroke();  buffer.textSize(step);  buffer.textFont('Courier New');     if (isWordMode) {    buffer.textAlign(LEFT, TOP);    for (let y = 0; y < img.height; y += step) {      let x = 0;      while(x < img.width) {        let c = img.get(int(x), int(y));        let b = brightness(c);                let index;        if (isInvert) index = floor(map(b, 0, 255, sortedWordPalette.length - 1, 0));        else index = floor(map(b, 0, 255, 0, sortedWordPalette.length - 1));                index = constrain(index, 0, sortedWordPalette.length - 1);        let wordToDraw = sortedWordPalette[index];        let fillCol = isTwoTone ? color(textColorPicker.value()) : c;                if (b < 100) {           buffer.textStyle(BOLD);           if (b < 50) { buffer.strokeWeight(0.5); buffer.stroke(fillCol); }            else { buffer.noStroke(); }        } else {           buffer.textStyle(NORMAL); buffer.noStroke();        }                buffer.fill(fillCol);        buffer.text(wordToDraw, x, y);        x += buffer.textWidth(wordToDraw) + 4;       }    }  } else {    buffer.textAlign(CENTER, CENTER);    for (let y = 0; y < img.height; y += step) {      for (let x = 0; x < img.width; x += step) {        let c = img.get(int(x), int(y));        let b = brightness(c);                let index;        if (isInvert) index = floor(map(b, 0, 255, sortedLetterPalette.length - 1, 0));        else index = floor(map(b, 0, 255, 0, sortedLetterPalette.length - 1));                index = constrain(index, 0, sortedLetterPalette.length - 1);        let charToDraw = sortedLetterPalette.charAt(index);        let fillCol = isTwoTone ? color(textColorPicker.value()) : c;                if (b < 100) {           buffer.textStyle(BOLD);           if (b < 50) { buffer.strokeWeight(0.5); buffer.stroke(fillCol); }            else { buffer.noStroke(); }        } else {           buffer.textStyle(NORMAL); buffer.noStroke();        }                buffer.fill(fillCol);        buffer.text(charToDraw, x + step/2, y + step/2);      }    }  }    redraw();}function calculatePalettes() {  let inputStr = txtInput.value();  if (inputStr.length === 0) return;  // Letters  let chars = Array.from(new Set(inputStr.split('')));  let pg = createGraphics(30, 30);  pg.pixelDensity(1);  pg.textFont('Courier New');  pg.textSize(20);  pg.textAlign(CENTER, CENTER);  let charDensities = [];  for (let c of chars) {    pg.clear(); pg.background(255); pg.fill(0); pg.textStyle(NORMAL);    pg.text(c, 15, 15);    pg.loadPixels();    let dark = 0;    for (let i=0; i<pg.pixels.length; i+=4) if(pg.pixels[i]<200) dark++;    charDensities.push({ char: c, density: dark });  }  charDensities.sort((a, b) => b.density - a.density);  sortedLetterPalette = charDensities.map(i => i.char).join('');  pg.remove();   // Words  let words = inputStr.split(' ').filter(w => w.length > 0);  words = Array.from(new Set(words));    pg = createGraphics(200, 50);  pg.pixelDensity(1);  pg.textFont('Courier New');  pg.textSize(20);  pg.textAlign(CENTER, CENTER);    let wordDensities = [];  for (let w of words) {    pg.clear(); pg.background(255); pg.fill(0); pg.textStyle(NORMAL);    pg.text(w, 100, 25);    pg.loadPixels();    let dark = 0;    for (let i=0; i<pg.pixels.length; i+=4) if(pg.pixels[i]<200) dark++;    wordDensities.push({ word: w, density: dark });  }  wordDensities.sort((a, b) => b.density - a.density);  sortedWordPalette = wordDensities.map(i => i.word);  pg.remove();}function saveHighRes() {  if (!img) return;  let exportScale = 4;   let pg = createGraphics(img.width * exportScale, img.height * exportScale);    let isTwoTone = twoToneCheckbox.checked();  let isWordMode = modeCheckbox.checked();  let isInvert = invertCheckbox.checked();    pg.background(bgColorPicker.value());    let step = resolutionSlider.value();  let finalStep = step * exportScale;     pg.noStroke();  pg.textSize(finalStep);  pg.textFont('Courier New');     if (isWordMode) {    pg.textAlign(LEFT, TOP);    for (let y = 0; y < img.height; y += step) {      let x = 0;      while(x < img.width) {        let c = img.get(int(x), int(y));        let b = brightness(c);        let index;        if (isInvert) index = floor(map(b, 0, 255, sortedWordPalette.length - 1, 0));        else index = floor(map(b, 0, 255, 0, sortedWordPalette.length - 1));        index = constrain(index, 0, sortedWordPalette.length - 1);        let wordToDraw = sortedWordPalette[index];        let fillCol = isTwoTone ? color(textColorPicker.value()) : c;        if (b < 100) {           pg.textStyle(BOLD);           if (b < 50) { pg.strokeWeight(0.5 * exportScale); pg.stroke(fillCol); }            else { pg.noStroke(); }        } else {           pg.textStyle(NORMAL); pg.noStroke();        }        pg.fill(fillCol);        pg.text(wordToDraw, x * exportScale, y * exportScale);        x += buffer ? (buffer.textWidth(wordToDraw) + 4) : 10;       }    }  } else {    pg.textAlign(CENTER, CENTER);    for (let y = 0; y < img.height; y += step) {      for (let x = 0; x < img.width; x += step) {        let c = img.get(int(x), int(y));        let b = brightness(c);        let index;        if (isInvert) index = floor(map(b, 0, 255, sortedLetterPalette.length - 1, 0));        else index = floor(map(b, 0, 255, 0, sortedLetterPalette.length - 1));        index = constrain(index, 0, sortedLetterPalette.length - 1);        let charToDraw = sortedLetterPalette.charAt(index);        let fillCol = isTwoTone ? color(textColorPicker.value()) : c;        if (b < 100) {           pg.textStyle(BOLD);           if (b < 50) { pg.strokeWeight(0.5 * exportScale); pg.stroke(fillCol); }            else { pg.noStroke(); }        } else {           pg.textStyle(NORMAL); pg.noStroke();        }        pg.fill(fillCol);        pg.text(charToDraw, (x * exportScale) + finalStep/2, (y * exportScale) + finalStep/2);      }    }  }    save(pg, 'raster-art-' + int(random(1000)) + '.png');  pg.remove();}function handleFile(file) {  if (file.type === 'image') {    img = loadImage(file.data, () => {      if (img.width > 2500 || img.height > 2500) {        let r = img.width / img.height;        if (r > 1) img.resize(2500, 0);        else img.resize(0, 2500);      }      img.loadPixels();      calculatePalettes();       updateBuffer();    });  }}function windowResized() {  resizeCanvas(windowWidth, windowHeight);  redraw();}