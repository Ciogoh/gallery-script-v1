let textTexture;let p5Canvas; // HTML Elementslet textInput;let sizeSlider;let widthSlider;let colorPicker;let sphereSizeSlider;let bgAlphaSlider; let bgColorPicker; let vCoverageSlider; let hCoverageSlider; // CHANGED: Now a percentage sliderlet bundleCheck; let btnGif; let btnPng; // Display Elementslet currentHeightDisplay;let currentWidthDisplay;let currentSphereSizeDisplay;let currentBgAlphaDisplay; let currentVCoverageDisplay; let currentHCoverageDisplay; // CHANGED// State Variableslet sphereText = "make\nit Curvy";let currentTextSize = 60; let currentTextScaleX = 1.0; let currentTextColor = '#FFFF00'; let currentSphereSize = 150; let currentBgAlpha = 40; let currentBgColor = '#323232'; let currentVCoverage = 50; let currentHCoverage = 50; // CHANGED: Defaults to 50%let isBundled = false; const detail = 60; // Rotation Variableslet totalRotationX = 0;let totalRotationY = 0;let autoRotationY = 0; const rotationSpeed = 0.01; const continuousSpeed = 0.003; function setup() {  let canvas = createCanvas(600, 400, WEBGL);  canvas.parent('p5-container');   p5Canvas = canvas.elt;    // 1. Get HTML elements  textInput = document.getElementById('textInput');  sizeSlider = document.getElementById('sizeSlider');  widthSlider = document.getElementById('widthSlider');  colorPicker = document.getElementById('colorPicker');  sphereSizeSlider = document.getElementById('sphereSizeSlider');  bgAlphaSlider = document.getElementById('bgAlphaSlider');  bgColorPicker = document.getElementById('bgColorPicker');   vCoverageSlider = document.getElementById('vCoverageSlider');   hCoverageSlider = document.getElementById('hCoverageSlider'); // CHANGED  bundleCheck = document.getElementById('bundleCheck');   btnGif = document.getElementById('btnGif');   btnPng = document.getElementById('btnPng');   currentHeightDisplay = document.getElementById('currentHeight');  currentWidthDisplay = document.getElementById('currentWidth');  currentSphereSizeDisplay = document.getElementById('currentSphereSize');  currentBgAlphaDisplay = document.getElementById('currentBgAlpha');   currentVCoverageDisplay = document.getElementById('currentVCoverage');   currentHCoverageDisplay = document.getElementById('currentHCoverage'); // CHANGED  // 2. Set up event listeners  textInput.addEventListener('input', updateSphereText);  sizeSlider.addEventListener('input', updateTextHeight);  widthSlider.addEventListener('input', updateTextWidth);  colorPicker.addEventListener('input', updateTextColor);   sphereSizeSlider.addEventListener('input', updateSphereSize);  bgAlphaSlider.addEventListener('input', updateBgAlpha);  bgColorPicker.addEventListener('input', updateBgColor);  vCoverageSlider.addEventListener('input', updateVCoverage);   hCoverageSlider.addEventListener('input', updateHCoverage); // CHANGED  bundleCheck.addEventListener('change', updateBundle);  btnGif.addEventListener('click', saveAnimation);  btnPng.addEventListener('click', saveStaticImage);    // 3. Create the 2D Graphics buffer  textTexture = createGraphics(1024, 1024);     // Initial Syncs  drawTextureText();  updateBgColor(); }// --- EXPORT FUNCTIONS ---function saveAnimation() {  btnGif.textContent = "Recording (Wait 3s)...";  btnGif.disabled = true;  saveGif('sphere_anim', 3, { units: 'seconds' });  setTimeout(() => {    btnGif.textContent = "Save GIF (3s Loop)";    btnGif.disabled = false;  }, 4000);}function saveStaticImage() {  saveCanvas('sphere_snapshot', 'png');}// --- Update Functions ---function updateSphereText() {  sphereText = textInput.value.toUpperCase();   drawTextureText(); }function updateTextHeight() {  currentTextSize = parseInt(sizeSlider.value);  currentHeightDisplay.textContent = currentTextSize;  drawTextureText(); }function updateTextWidth() {  currentTextScaleX = parseFloat(widthSlider.value);  currentWidthDisplay.textContent = currentTextScaleX.toFixed(2);  drawTextureText(); }function updateTextColor() {  currentTextColor = colorPicker.value;  drawTextureText(); }function updateSphereSize() {  currentSphereSize = parseInt(sphereSizeSlider.value);  currentSphereSizeDisplay.textContent = currentSphereSize;}function updateBgAlpha() {  currentBgAlpha = parseInt(bgAlphaSlider.value);  currentBgAlphaDisplay.textContent = currentBgAlpha;  drawTextureText(); }function updateBgColor() {  currentBgColor = bgColorPicker.value;  document.body.style.backgroundColor = currentBgColor;}function updateVCoverage() {  currentVCoverage = parseInt(vCoverageSlider.value);  currentVCoverageDisplay.textContent = currentVCoverage + "%";  drawTextureText();}// CHANGED: Updates Percentagefunction updateHCoverage() {  currentHCoverage = parseInt(hCoverageSlider.value);  currentHCoverageDisplay.textContent = currentHCoverage + "%";  drawTextureText();}function updateBundle() {  isBundled = bundleCheck.checked;  drawTextureText();}// --- Mouse Interaction ---function mouseDragged() {  if (mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height) {      let deltaX = mouseX - pmouseX;      let deltaY = mouseY - pmouseY;      totalRotationY += deltaX * rotationSpeed;      totalRotationX -= deltaY * rotationSpeed;      return false;   }}// --- MAIN DRAW LOOP ---function draw() {  background(currentBgColor);     autoRotationY += continuousSpeed;     pointLight(255, 255, 255, 100, 100, 300);   ambientLight(150);     translate(0, 0, 0);  rotateX(totalRotationX);  rotateY(totalRotationY + autoRotationY);   noStroke();   let gl = drawingContext;  gl.enable(gl.CULL_FACE);  gl.depthMask(false);   texture(textTexture);  // INSIDE  gl.cullFace(gl.FRONT);  sphere(currentSphereSize, detail, detail);  // OUTSIDE  gl.cullFace(gl.BACK);  sphere(currentSphereSize, detail, detail);  gl.depthMask(true);  gl.disable(gl.CULL_FACE);}// --- FULLY DYNAMIC LOGIC (Vert & Horiz Percentages) ---function drawTextureText() {  textTexture.clear();     if (currentBgAlpha > 0) {    textTexture.background(255, 255, 255, currentBgAlpha);   }    textTexture.fill(currentTextColor);   textTexture.textAlign(CENTER, CENTER);  textTexture.textSize(currentTextSize);    textTexture.push();  textTexture.translate(textTexture.width / 2, textTexture.height / 2);  textTexture.scale(currentTextScaleX, 1.0);   // --- 1. MEASURE DIMENSIONS ---    let lines = sphereText.split('\n');  let lineHeight = currentTextSize * 1.1;   let singleBlockHeight = lines.length * lineHeight;  // Measure the widest line of text  // We must account for the ScaleX user setting  let maxLineWidth = 0;  for (let l of lines) {    let w = textTexture.textWidth(l);    if (w > maxLineWidth) maxLineWidth = w;  }  // The actual width on texture includes the scale transformation  // But textTexture.textWidth doesn't know about scale(), so we don't multiply here  // because we are scaling the whole canvas context below.   // Wait, actually, for calculation logic we need "effective" width relative to texture width.  // Since we scale the drawing context, the texture width is effectively "shrunk" or "stretched".  // Let's simplify: We compare textWidth against textureWidth/scaleX.  let singleBlockWidth = maxLineWidth;   // --- 2. CALCULATE QUANTITIES ---  // Vertical Count  let maxVRepeats = Math.floor(textTexture.height / (singleBlockHeight * 1.05));  if (maxVRepeats < 1) maxVRepeats = 1;  let calculatedVRows = Math.floor(maxVRepeats * (currentVCoverage / 100));  if (currentVCoverage > 0 && calculatedVRows < 1) calculatedVRows = 1;  if (currentVCoverage === 0) calculatedVRows = 0;  // Horizontal Count  // We divide texture width by the visual width of the text (plus 5% buffer)  // Note: We divide by currentTextScaleX to normalize the comparison  let effectiveTextureWidth = textTexture.width / currentTextScaleX;  let maxHRepeats = Math.floor(effectiveTextureWidth / (singleBlockWidth * 1.1));  if (maxHRepeats < 1) maxHRepeats = 1;    let calculatedHCols = Math.floor(maxHRepeats * (currentHCoverage / 100));  if (currentHCoverage > 0 && calculatedHCols < 1) calculatedHCols = 1;  if (currentHCoverage === 0) calculatedHCols = 0;  // --- 3. SPACING LOGIC (Bundle vs Spread) ---  let vRowHeight, vStartY;  let hColWidth, hStartX;  if (isBundled) {      // BUNDLED: Tightly packed based on content size            // Vertical      vRowHeight = singleBlockHeight;       let totalVHeight = calculatedVRows * vRowHeight;      vStartY = -totalVHeight / 2 + (vRowHeight / 2);      // Horizontal      // In bundled mode, we use the visual width of the text block      // We perform calculation in "Unscaled" space, then let the scale() handle it      hColWidth = singleBlockWidth * 1.1; // 1.1 adds a small gap between bundles      let totalHWidth = calculatedHCols * hColWidth;      hStartX = -totalHWidth / 2 + (hColWidth / 2);  } else {      // SPREAD: Evenly distributed across texture space            // Vertical      vRowHeight = textTexture.height / calculatedVRows;      vStartY = -textTexture.height / 2 + (vRowHeight / 2);      // Horizontal      // We divide the "effective" width (unscaled width) by columns      let spreadWidth = (textTexture.width / currentTextScaleX);      hColWidth = spreadWidth / calculatedHCols;      hStartX = -spreadWidth / 2 + (hColWidth / 2);  }  // --- 4. DRAW LOOP ---  for (let r = 0; r < calculatedVRows; r++) {    let rowCenterY = vStartY + (r * vRowHeight);    let textStartY = rowCenterY - (singleBlockHeight / 2) + (lineHeight / 2);    for (let h = 0; h < calculatedHCols; h++) {        let colCenterX = hStartX + (h * hColWidth);        for (let i = 0; i < lines.length; i++) {          let currentLineStr = lines[i];          let lineOffsetY = i * lineHeight;          textTexture.text(currentLineStr, colCenterX, textStartY + lineOffsetY);        }    }  }  textTexture.pop(); }