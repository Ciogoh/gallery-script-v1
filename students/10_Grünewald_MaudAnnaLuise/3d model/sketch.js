let tapModel;let mic, fft;let drops = [];let ripples = [];// HTML Elementslet emptyButton;let fullLabel;let titleLabel;let instructionLabel;let startOverlay;let micIndicator;// --- STATE ---let isAudioStarted = false;// --- SCENE CONFIG ---let sceneScale = 1.4; let sceneOffsetY = -20;// --- TAP COORDINATES ---let spoutX = -13;let spoutY = -37;let spoutZ = -47;// --- GLASS COORDINATES ---let glassX = 22;let glassY = 72;let glassZ = -39;let glassBottom = 102; // --- WATER LEVEL ---let collectedWaterHeight = 0;let maxWaterHeight = 55;function preload() {  tapModel = loadModel('Tap.obj', true);}function setup() {  createCanvas(600, 600, WEBGL);    mic = new p5.AudioIn();  fft = new p5.FFT();  fft.setInput(mic);  setupUI();}function setupUI() {  // 1. TITLE  titleLabel = createDiv("fill the glass!");  titleLabel.position(0, 20);  titleLabel.style('width', '600px');  titleLabel.style('text-align', 'center');  titleLabel.style('font-family', 'Helvetica, sans-serif');  titleLabel.style('font-size', '24px');  titleLabel.style('font-weight', 'bold');  titleLabel.style('color', '#ffffff');    // 2. INSTRUCTIONS  instructionLabel = createDiv("make a 'shh' sound to release water");  instructionLabel.position(0, 60);   instructionLabel.style('width', '600px');  instructionLabel.style('text-align', 'center');  instructionLabel.style('font-family', 'Helvetica, sans-serif');  instructionLabel.style('font-size', '14px');  instructionLabel.style('color', '#aaaaaa');  // 3. BUTTON  emptyButton = createButton("empty glass");  emptyButton.position(width/2 - 60, height - 60);   emptyButton.mousePressed(emptyGlass);    emptyButton.style('font-family', 'Helvetica, sans-serif');  emptyButton.style('background-color', '#000000');   emptyButton.style('color', '#ffffff');  emptyButton.style('border', '1px solid #ffffff');  emptyButton.style('padding', '12px 24px');  emptyButton.style('border-radius', '4px');  emptyButton.style('font-size', '14px');  emptyButton.style('cursor', 'pointer');  // 4. "full!" LABEL  fullLabel = createDiv("full!");  fullLabel.position(0, height - 110);   fullLabel.style('width', '600px');   fullLabel.style('text-align', 'center');    fullLabel.style('font-family', 'Helvetica, sans-serif');  fullLabel.style('color', '#ffffff');   fullLabel.style('font-size', '24px');  fullLabel.style('font-weight', 'bold');  fullLabel.style('text-shadow', '1px 1px 2px black');  fullLabel.hide();   // 5. MIC INDICATOR  micIndicator = createDiv("");  micIndicator.position(20, 20);  micIndicator.size(12, 12);  micIndicator.style('background-color', 'red');  micIndicator.style('border-radius', '50%');  micIndicator.style('box-shadow', '0px 0px 5px rgba(0,0,0,0.5)');  micIndicator.hide();   // 6. START OVERLAY  startOverlay = createDiv("<span>click to start</span>");  startOverlay.position(0, 0);  startOverlay.size(width, height);  startOverlay.style('display', 'flex');  startOverlay.style('align-items', 'center');  startOverlay.style('justify-content', 'center');  startOverlay.style('background', 'rgba(0,0,0,0.8)');  startOverlay.style('color', 'white');  startOverlay.style('font-family', 'Helvetica, sans-serif');  startOverlay.style('font-size', '30px');  startOverlay.style('font-weight', 'bold');  startOverlay.style('cursor', 'pointer');  startOverlay.mousePressed(startApp);}function startApp() {  userStartAudio();  mic.start();  isAudioStarted = true;  startOverlay.hide();  micIndicator.show(); }function emptyGlass() {  collectedWaterHeight = 0;  ripples = [];   fullLabel.hide();}function draw() {  background(20);   // --- CAMERA CONTROL ---  // orbitControl(sensitivityX, sensitivityY, zoomSpeed)  // sensitivityY is set to 0 to disable vertical rotation.  // sensitivityX is 1 to allow horizontal rotation.  orbitControl(1, 0, 0.2);  // --- LIGHTING ---  ambientLight(100);   directionalLight(255, 255, 255, 0, 0, -1);   directionalLight(100, 100, 120, 0.5, 0.5, -0.5);   // --- SCENE SETUP ---  push();  translate(0, sceneOffsetY, 0);  scale(sceneScale);  // --- 1. DRAW TAP ---  push();  noStroke();  ambientMaterial(60, 60, 60);      specularMaterial(255, 255, 255);   shininess(150);                    rotateX(PI);   rotateY(QUARTER_PI);   model(tapModel);  pop();  // --- 2. DRAW COLLECTED WATER ---  if (collectedWaterHeight > 0.1) {    push();    translate(glassX, glassBottom - (collectedWaterHeight / 2), glassZ);    noStroke();    fill(100, 200, 255, 120);     specularMaterial(255, 255, 255);    shininess(100);    cylinder(16.5, collectedWaterHeight);        // Surface    translate(0, -collectedWaterHeight/2, 0);    rotateX(HALF_PI);    fill(180, 230, 255, 180);     ellipse(0, 0, 16.5, 16.5);    pop();  }  // --- 3. DRAW GLASS ---  push();  translate(glassX, glassY, glassZ);  rotateX(PI);   fill(240, 250, 255, 30);   stroke(200, 230, 255, 80);   strokeWeight(1.5);  specularMaterial(255, 255, 255);  shininess(250);   cylinder(18, 60, 24, 1, true, false);  pop();  // --- 4. RIPPLES ---  let waterSurfaceY = 102 - collectedWaterHeight;  for (let i = ripples.length - 1; i >= 0; i--) {    ripples[i].update();    ripples[i].display(glassX, waterSurfaceY, glassZ);    if (ripples[i].isFinished()) {      ripples.splice(i, 1);    }  }  // --- 5. AUDIO & LOGIC ---  if (isAudioStarted) {    let spectrum = fft.analyze();    let trebleVol = fft.getEnergy("treble");     let midVol = fft.getEnergy("mid");         let isShh = trebleVol > 20 && trebleVol > midVol * 1.1;    let isFull = collectedWaterHeight >= maxWaterHeight;    if (isShh) {      micIndicator.style('background-color', '#00ff00');      micIndicator.style('box-shadow', '0px 0px 10px #00ff00');    } else {      micIndicator.style('background-color', '#ff0000');      micIndicator.style('box-shadow', 'none');    }    if (isFull) fullLabel.show();    else fullLabel.hide();    if (isShh && !isFull) {      if (trebleVol > 100) {         if(frameCount % 1 == 0) drops.push(new Drop(true));       } else {         if (random(1) < 0.15) drops.push(new Drop(false));      }    }  }  // --- 6. UPDATE & DRAW DROPS ---  for (let i = drops.length - 1; i >= 0; i--) {    drops[i].update();        if (drops[i].hasHitSurface(waterSurfaceY)) {      let fillAmount = drops[i].isStream ? 0.4 : 0.15;      if (collectedWaterHeight < maxWaterHeight) {        collectedWaterHeight += fillAmount;      }      if (!drops[i].isStream || frameCount % 8 === 0) {        ripples.push(new Ripple());      }      drops.splice(i, 1);    }  }  for (let i = 0; i < drops.length; i++) {    let current = drops[i];    let prev = (i > 0) ? drops[i-1] : null;    if (current.isStream && prev && prev.isStream && (current.y - prev.y) < 50) {      drawStreamConnection(current, prev);    } else {      current.display();    }  }    pop(); // END SCALED SCENE}// --- CLASSES ---class Drop {  constructor(isStream) {    this.isStream = isStream;     let angle = QUARTER_PI;    this.x = spoutX * cos(angle) - spoutZ * sin(angle);    this.z = spoutX * sin(angle) + spoutZ * cos(angle);    this.y = spoutY;         let scatter = this.isStream ? 0.05 : 0.5;    this.x += random(-scatter, scatter);    this.z += random(-scatter, scatter);    this.speed = 8;    this.gravity = 0.8;  }  update() {    this.speed += this.gravity;    this.y += this.speed;  }  display() {    push();    translate(this.x, this.y, this.z);    noStroke();    fill(180, 220, 255, 150);     specularMaterial(255, 255, 255);    shininess(200);    if (this.isStream) {      sphere(2.3);     } else {      let r = 2.5;      sphere(r);      translate(0, -r * 0.8, 0);       rotateX(PI);       cone(r * 0.9, r * 3);     }    pop();  }  hasHitSurface(surfaceY) {    return this.y >= surfaceY;   }}class Ripple {  constructor() {    this.radius = 1;    this.alpha = 200;  }  update() {    this.radius += 1.0;     this.alpha -= 10;   }  display(gx, gy, gz) {    push();    translate(gx, gy, gz);    rotateX(HALF_PI);     noFill();    stroke(255, 255, 255, this.alpha);     strokeWeight(1.5);    ellipse(0, 0, this.radius, this.radius);    pop();  }  isFinished() {    return this.alpha <= 0;  }}function drawStreamConnection(topDrop, bottomDrop) {  push();  let midX = (topDrop.x + bottomDrop.x) / 2;  let midY = (topDrop.y + bottomDrop.y) / 2;  let midZ = (topDrop.z + bottomDrop.z) / 2;  let d = dist(topDrop.x, topDrop.y, topDrop.z, bottomDrop.x, bottomDrop.y, bottomDrop.z);  translate(midX, midY, midZ);  noStroke();  fill(180, 220, 255, 180);   specularMaterial(255, 255, 255);  shininess(200);  cylinder(2.3, d * 1.1, 8, 1, false, false);  pop();}function mousePressed() {  userStartAudio();}